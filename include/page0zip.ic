/******************************************************
Compressed page interface

(c) 2005 Innobase Oy

Created June 2005 by Marko Makela
*******************************************************/

#ifdef UNIV_MATERIALIZE
# undef UNIV_INLINE
# define UNIV_INLINE
#endif

#include "page0zip.h"
#include "page0page.h"

/* The format of compressed pages is as follows.

The header and trailer of the uncompressed pages, excluding the page
directory in the trailer, are copied as is to the header and trailer
of the compressed page.

At the end of the compressed page, there is a dense page directory
pointing to every user record contained on the page, including deleted
records on the free list.  The dense directory is indexed in the
collation order, i.e., in the order in which the record list is
linked on the uncompressed page.  The infimum and supremum records are
excluded.  The two most significant bits of the entries are allocated
for the delete-mark and an n_owned flag indicating the last record in
a chain of records pointed to from the sparse page directory on the
uncompressed page.

The data between PAGE_ZIP_START and the last page directory entry will
be written in compressed format, starting at offset PAGE_DATA.
Infimum and supremum records are not stored.  We exclude the
REC_N_NEW_EXTRA_BYTES in every record header.  These can be recovered
from the dense page directory stored at the end of the compressed
page.

The fields node_ptr (in non-leaf B-tree nodes; level>0), trx_id and
roll_ptr (in leaf B-tree nodes; level=0), and BLOB pointers of
externally stored columns are stored separately, in ascending order of
heap_no and column index, starting backwards from the dense page
directory.

The compressed data stream may be followed by a modification log
covering the compressed portion of the page, as follows.

MODIFICATION LOG ENTRY FORMAT
- write record:
  - heap_no-1 (1..2 bytes)
  - extra bytes backwards
  - data bytes

The integer values are stored in a variable-length format:
- 0xxxxxxx: 0..127
- 1xxxxxxx xxxxxxxx: 0..32767

The end of the modification log is marked by a 0 byte.

In summary, the compressed page looks like this:

(1) Uncompressed page header (PAGE_DATA bytes)
(2) Compressed index information
(3) Compressed page data
(4) Page modification log (page_zip->m_start..page_zip->m_end)
(5) Empty zero-filled space
(6) BLOB pointers
  - BTR_EXTERN_FIELD_REF_SIZE for each externally stored column
  - in descending collation order
(7) Uncompressed columns of user records, n_dense * uncompressed_size bytes,
  - indexed by heap_no
  - DATA_TRX_ID_LEN + DATA_ROLL_PTR_LEN if page_is_leaf(page_zip->data)
  - REC_NODE_PTR_SIZE otherwise
(8) Original origins of records that have been relocated since
    the page was compressed, in ascending order, 16 bits per entry
(9) dense page directory, stored backwards
  - n_dense = n_heap - 2
  - existing records in ascending collation order
  - deleted records (free list) in link order
(10) Number of records that have been relocated
    since the page was compressed (16 bits), cf. (7)
*/

/* Start offset of the area that will be compressed */
#define PAGE_ZIP_START		PAGE_NEW_SUPREMUM_END
/* Size of an compressed page directory entry */
#define PAGE_ZIP_DIR_SLOT_SIZE	2
/* Mask of record offsets */
#define PAGE_ZIP_DIR_SLOT_MASK	0x3fff
/* 'owned' flag */
#define PAGE_ZIP_DIR_SLOT_OWNED	0x4000
/* 'deleted' flag */
#define PAGE_ZIP_DIR_SLOT_DEL	0x8000

/**************************************************************************
Initialize a compressed page descriptor. */
UNIV_INLINE
void
page_zip_des_init(
/*==============*/
	page_zip_des_t*	page_zip)	/* in/out: compressed page
					descriptor */
{
	memset(page_zip, 0, sizeof *page_zip);
}

#ifdef UNIV_DEBUG
/**************************************************************************
Validate a compressed page descriptor. */
UNIV_INLINE
ibool
page_zip_simple_validate(
/*=====================*/
					/* out: TRUE if ok */
	const page_zip_des_t*	page_zip)/* in: compressed page descriptor */
{
	ut_ad(page_zip);
	ut_ad(page_zip->data);
	ut_ad(!(page_zip->size & (page_zip->size - 1))); /* power of 2 */
	ut_ad(page_zip->size <= UNIV_PAGE_SIZE);
	ut_ad(page_zip->size > PAGE_DATA + PAGE_ZIP_DIR_SLOT_SIZE);
	ut_ad(page_zip->m_start <= page_zip->m_end);
	ut_ad(page_zip->m_end < page_zip->size);
	ut_ad(page_zip->n_blobs < page_zip->size / BTR_EXTERN_FIELD_REF_SIZE);
	return(TRUE);
}
#endif /* UNIV_DEBUG */

/*****************************************************************
Gets the number of records that have been relocated, that is,
allocated from the free list since the page was compressed,
such that extra_size has grown. */
UNIV_INLINE
ulint
page_zip_get_n_relocated(
/*=====================*/
						/* out: number of records
						that have been relocated */
	const page_zip_des_t*	page_zip)	/* in: compressed page */
{
	return(mach_read_from_2(page_zip->data
			+ page_zip->size - PAGE_ZIP_DIR_SLOT_SIZE));
}

/*****************************************************************
Sets the number of records that have been relocated, that is,
allocated from the free list since the page was compressed,
such that extra_size has grown. */
UNIV_INLINE
void
page_zip_set_n_relocated(
/*=====================*/
	const page_zip_des_t*	page_zip,	/* in: compressed page */
	ulint			n_relocated)	/* in: number of records
						that have been relocated */
{
	mach_write_to_2(page_zip->data
			+ page_zip->size - PAGE_ZIP_DIR_SLOT_SIZE,
			n_relocated);
}

/*****************************************************************
Gets original offset of a record that has been relocated, that is,
allocated from the free list since the page was compressed,
such that extra_size has grown. */
UNIV_INLINE
ulint
page_zip_get_relocated(
/*===================*/
						/* out: original offset
						of the record */
	const page_zip_des_t*	page_zip,	/* in: compressed page */
	ulint			i)		/* in: ith record */
{
#ifdef UNIV_DEBUG
	ulint		n	= page_zip_get_n_relocated(page_zip);
#endif /* UNIV_DEBUG */
	ulint		offset;

	ut_ad(i < n);

	/* Below, we subtract 2 from n_heap for the page infimum and supremum,
	but add 1 for n_relocated, and index by i + 1 */
	offset = mach_read_from_2(page_zip->data
			+ page_zip->size - PAGE_ZIP_DIR_SLOT_SIZE
			* (page_dir_get_n_heap(page_zip->data) + i));

	ut_ad(offset >= PAGE_ZIP_START);
	ut_ad(offset < page_zip->size - PAGE_ZIP_DIR_SLOT_SIZE
			* (page_dir_get_n_heap(page_zip->data) + n - 1));

	return(offset);
}

/*****************************************************************
Gets the size of the compressed page trailer (the dense page directory),
including deleted records (the free list) and n_relocated. */
UNIV_INLINE
ulint
page_zip_dir_size(
/*==============*/
						/* out: length of dense page
						directory, in bytes */
	const page_zip_des_t*	page_zip)	/* in: compressed page */
{
	/* Exclude the page infimum and supremum from the record count.
	Add 1 slot for n_relocated. */
	ulint	size = PAGE_ZIP_DIR_SLOT_SIZE
			* (page_dir_get_n_heap((page_t*) page_zip->data) - 1);
	ut_ad(page_zip->m_end + size < page_zip->size);
	return(size);
}

/*****************************************************************
Gets the size of the compressed page trailer (the dense page directory),
only including user records (excluding the free list and n_relocated). */
UNIV_INLINE
ulint
page_zip_dir_user_size(
/*===================*/
						/* out: length of dense page
						directory comprising existing
						records, in bytes */
	const page_zip_des_t*	page_zip)	/* in: compressed page */
{
	ulint	size = PAGE_ZIP_DIR_SLOT_SIZE
			* page_get_n_recs((page_t*) page_zip->data);
	ut_ad(size < page_zip_dir_size(page_zip));
	return(size);
}

/*****************************************************************
Find the slot of the given non-free record in the dense page directory. */
UNIV_INLINE
byte*
page_zip_dir_find(
/*==============*/
						/* out: dense directory slot,
						or NULL if record not found */
	page_zip_des_t*	page_zip,		/* in: compressed page */
	ulint		offset)			/* in: offset of user record */
{
	byte*	slot;
	byte*	end;

	ut_ad(page_zip_simple_validate(page_zip));

	end = page_zip->data + page_zip->size - PAGE_ZIP_DIR_SLOT_SIZE;
	slot = end - page_zip_dir_user_size(page_zip);

	for (; slot < end; slot += PAGE_ZIP_DIR_SLOT_SIZE) {
		if ((mach_read_from_2(slot) & PAGE_ZIP_DIR_SLOT_MASK)
				== offset) {
			return(slot);
		}
	}

	return(NULL);
}

/*****************************************************************
Find the slot of the given free record in the dense page directory. */
UNIV_INLINE
byte*
page_zip_dir_find_free(
/*===================*/
						/* out: dense directory slot,
						or NULL if record not found */
	page_zip_des_t*	page_zip,		/* in: compressed page */
	ulint		offset)			/* in: offset of user record */
{
	byte*	slot;
	byte*	end;

	ut_ad(page_zip_simple_validate(page_zip));

	slot = end = page_zip->data + page_zip->size;
	slot -= page_zip_dir_size(page_zip);
	end -= PAGE_ZIP_DIR_SLOT_SIZE + page_zip_dir_user_size(page_zip);

	for (; slot < end; slot += PAGE_ZIP_DIR_SLOT_SIZE) {
		if ((mach_read_from_2(slot) & PAGE_ZIP_DIR_SLOT_MASK)
				== offset) {
			return(slot);
		}
	}

	return(NULL);
}

/*****************************************************************
Read a given slot in the dense page directory. */
UNIV_INLINE
ulint
page_zip_dir_get(
/*=============*/
						/* out: record offset
						on the uncompressed page,
						possibly ORed with
						PAGE_ZIP_DIR_SLOT_DEL or
						PAGE_ZIP_DIR_SLOT_OWNED */
	const page_zip_des_t*	page_zip,	/* in: compressed page */
	ulint			slot)		/* in: slot
						(0=first user record) */
{
	ut_ad(page_zip_simple_validate(page_zip));
	ut_ad(slot < page_zip_dir_size(page_zip) / PAGE_ZIP_DIR_SLOT_SIZE);
	/* Add 1 for n_relocated */
	return(mach_read_from_2(page_zip->data + page_zip->size
			- PAGE_ZIP_DIR_SLOT_SIZE * (slot + 2)));
}
/*****************************************************************
Write a given slot in the dense page directory. */
UNIV_INLINE
void
page_zip_dir_set(
/*=============*/
	page_zip_des_t*	page_zip,	/* in: compressed page */
	ulint		slot,		/* in: slot (0=first user record) */
	ulint		offs)		/* in: offset, possibly ORed with
					PAGE_ZIP_DIR_SLOT_DEL or
					PAGE_ZIP_DIR_SLOT_OWNED */
{
	ut_ad(page_zip_simple_validate(page_zip));
	/* Add 1 for n_relocated */
	mach_write_to_2(page_zip->data + page_zip->size
			- PAGE_ZIP_DIR_SLOT_SIZE * (slot + 2),
			offs);
}

/**************************************************************************
Ensure that enough space is available in the modification log.
If not, try to compress the page. */
UNIV_INLINE
ibool
page_zip_alloc(
/*===========*/
				/* out: TRUE if enough space is available */
	page_zip_des_t*	page_zip,/* in/out: compressed page;
				will only be modified if compression is needed
				and successful */
	const page_t*	page,	/* in: uncompressed page */
	dict_index_t*	index,	/* in: index of the B-tree node */
	mtr_t*		mtr,	/* in: mini-transaction handle,
				or NULL if no logging is desired */
	ulint		length,	/* in: combined size of the record */
	ulint		create)	/* in: nonzero=add the record to the heap */
{
	ut_ad(page_is_comp((page_t*) page));
	ut_ad(page_zip_validate(page_zip, page));

	if (page_zip_available(page_zip, length, page_is_leaf(page), create)) {
		return(TRUE);
	}

	if (page_zip->m_start == page_zip->m_end) {
		/* The page has been freshly compressed, so
		recompressing it will not help. */
		return(FALSE);
	}

	if (!page_zip_compress(page_zip, page, index, mtr)) {
		/* Unable to compress the page */
		return(FALSE);
	}

	/* Check if there is enough space available after compression. */
	return(page_zip_available(page_zip, length,
				page_is_leaf(page), create));
}

/**************************************************************************
Determine if enough space is available in the modification log. */
UNIV_INLINE
ibool
page_zip_available(
/*===============*/
					/* out: TRUE if enough space
					is available */
	const page_zip_des_t*	page_zip,/* in: compressed page */
	ulint			length,	/* in: combined size of the record */
	ulint			is_leaf,/* in: nonzero=leaf node,
					zero=node pointer page */
	ulint			create)	/* in: nonzero=add the record to
					the heap */
{
	ulint	uncompressed_size;
	ulint	trailer_len;

	ut_ad(page_zip_simple_validate(page_zip));
	ut_ad(length > REC_N_NEW_EXTRA_BYTES);

	if (is_leaf) {
		uncompressed_size = PAGE_ZIP_DIR_SLOT_SIZE
				+ DATA_TRX_ID_LEN + DATA_ROLL_PTR_LEN;
	} else {
		uncompressed_size = PAGE_ZIP_DIR_SLOT_SIZE
				+ REC_NODE_PTR_SIZE;
	}

	trailer_len = page_get_n_recs((page_t*) page_zip->data)
				* uncompressed_size
				+ page_zip->n_blobs
				* BTR_EXTERN_FIELD_REF_SIZE;

	/* Subtract the fixed extra bytes and add the maximum
	space needed for identifying the record (encoded heap_no). */
	length -= REC_N_NEW_EXTRA_BYTES - 2;

	if (UNIV_UNLIKELY(create)) {
		/* When a record is created, a pointer may be added to
		the dense directory or to the list of relocated records.
		Likewise, space for the columns that will not be
		compressed will be allocated from the page trailer.
		Also the BLOB pointers will be allocated from there, but
		we may as well count them in the length of the record. */

		trailer_len += PAGE_ZIP_DIR_SLOT_SIZE + uncompressed_size;
	}

	return(UNIV_LIKELY(
		length
		+ trailer_len
		+ page_zip->m_end
		< page_zip->size));
}

/**************************************************************************
Write data to the uncompressed header portion of a page.  The data must
already have been written to the uncompressed page.
However, the data portion of the uncompressed page may differ from
the compressed page when a record is being inserted in
page_cur_insert_rec_low(). */
UNIV_INLINE
void
page_zip_write_header(
/*==================*/
	page_zip_des_t*	page_zip,/* in/out: compressed page */
	const byte*	str,	/* in: address on the uncompressed page */
	ulint		length)	/* in: length of the data */
{
	ulint	pos;

	ut_ad(buf_block_get_page_zip(buf_block_align((byte*)str)) == page_zip);
	ut_ad(page_zip_simple_validate(page_zip));

	pos = ut_align_offset(str, UNIV_PAGE_SIZE);

	ut_ad(pos < PAGE_DATA);

	memcpy(page_zip + pos, str, length);

	/* The following would fail in page_cur_insert_rec_low(). */
	/* ut_ad(page_zip_validate(page_zip, str - pos)); */
}

#ifdef UNIV_MATERIALIZE
# undef UNIV_INLINE
# define UNIV_INLINE	UNIV_INLINE_ORIGINAL
#endif
