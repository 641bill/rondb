/******************************************************
Compressed page interface

(c) 2005 Innobase Oy

Created June 2005 by Marko Makela
*******************************************************/

#ifdef UNIV_MATERIALIZE
# undef UNIV_INLINE
# define UNIV_INLINE
#endif

#include "page0zip.h"
#include "page0page.h"

/* The format of compressed pages is as follows.

The header and trailer of the uncompressed pages, excluding the page
directory in the trailer, are copied as is to the header and trailer
of the compressed page.

At the end of the compressed page, there is a dense page directory
pointing to every user record contained on the page, including deleted
records on the free list.  The dense directory is indexed by the
record heap number.  The infimum and supremum records are excluded.
The two most significant bits of the entries are allocated for the
delete-mark and an n_owned flag indicating the last record in a chain
of records pointed to from the sparse page directory on the
uncompressed page.

The data between PAGE_ZIP_START and the last page directory entry will
be written in compressed format, starting at offset PAGE_DATA.
Infimum and supremum records are not stored.  We exclude the
REC_N_NEW_EXTRA_BYTES in every record header.  These can be recovered
from the dense page directory stored at the end of the compressed
page.

The compressed data stream may be followed by a modification log
covering the compressed portion of the page, as follows.

MODIFICATION LOG ENTRY FORMAT
- length (1..2 bytes), not zero
- offset - PAGE_ZIP_START (1..2 bytes)
- data bytes

The length and the offset are stored in a variable-length format:
- 0xxxxxxxx : 0..127
- 10xxxxxxx xxxxxxxx: 0..16383
- 11xxxxxxx xxxxxxxx: reserved

The end of the modification log is marked by length=0. */

/* Start offset of the area that will be compressed */
#define PAGE_ZIP_START		PAGE_NEW_SUPREMUM_END
/* Size of an compressed page directory entry */
#define PAGE_ZIP_DIR_SLOT_SIZE	2
/* Mask of record offsets */
#define PAGE_ZIP_DIR_SLOT_MASK	0x3fff
/* 'owned' flag */
#define PAGE_ZIP_DIR_SLOT_OWNED	0x4000
/* 'deleted' flag */
#define PAGE_ZIP_DIR_SLOT_DEL	0x8000

/**************************************************************************
Initialize a compressed page descriptor. */
UNIV_INLINE
void
page_zip_des_init(
/*==============*/
	page_zip_des_t*	page_zip)	/* in/out: compressed page
					descriptor */
{
	memset(page_zip, 0, sizeof *page_zip);
}

/**************************************************************************
Determine the encoded length of an integer in the modification log. */
UNIV_INLINE
ulint
page_zip_ulint_size(
/*================*/
			/* out: length of the integer, in bytes */
	ulint	num)	/* in: the integer */
{
	if (num < 128) {	/* 0xxxxxxx: 0..127 */
		return(1);
	}
	if (num < 16384) {	/* 10xxxxxx xxxxxxxx: 0..16383 */
		return(2);
	}
	ut_ad(0);
	return(0);
}

/**************************************************************************
Determine the size of a modification log entry. */
UNIV_INLINE
ulint
page_zip_entry_size(
/*================*/
			/* out: length of the log entry, in bytes */
	ulint	pos,	/* in: offset of the uncompressed page */
	ulint	length)	/* in: length of the data */
{
	ut_ad(pos >= PAGE_ZIP_START);
	ut_ad(pos + length <= UNIV_PAGE_SIZE - PAGE_ZIP_START
		/* - trailer_len */);
	return(page_zip_ulint_size(pos - PAGE_ZIP_START)
		+ page_zip_ulint_size(length)
		+ length);
}

#ifdef UNIV_DEBUG
/**************************************************************************
Validate a compressed page descriptor. */
UNIV_INLINE
ibool
page_zip_simple_validate(
/*=====================*/
					/* out: TRUE if ok */
	const page_zip_des_t*	page_zip)/* in: compressed page descriptor */
{
	ut_ad(page_zip);
	ut_ad(page_zip->data);
	ut_ad(!(page_zip->size & (page_zip->size - 1))); /* power of 2 */
	ut_ad(page_zip->size <= UNIV_PAGE_SIZE);
	ut_ad(page_zip->size > PAGE_DATA + PAGE_ZIP_DIR_SLOT_SIZE);
	ut_ad(page_zip->m_start >= PAGE_DATA);
	ut_ad(page_zip->m_start <= page_zip->m_end);
	ut_ad(page_zip->m_end < page_zip->size);
	return(TRUE);
}
#endif /* UNIV_DEBUG */

/*****************************************************************
Gets the size of the compressed page trailer (the dense page directory). */
UNIV_INLINE
ulint
page_zip_dir_size(
/*==============*/
						/* out: length of dense page
						directory, in bytes */
	const page_zip_des_t*	page_zip)	/* in: compressed page */
{
	ulint	size = PAGE_ZIP_DIR_SLOT_SIZE
			* (page_dir_get_n_heap((page_t*) page_zip->data) - 2);
	ut_ad(page_zip->m_end + size < page_zip->size);
	return(size);
}

/*****************************************************************
Read a given slot in the dense page directory. */
UNIV_INLINE
ulint
page_zip_dir_get(
/*==============*/
						/* out: record offset
						on the uncompressed page,
						possibly ORed with
						PAGE_ZIP_DIR_SLOT_DEL or
						PAGE_ZIP_DIR_SLOT_OWNED */
	const page_zip_des_t*	page_zip,	/* in: compressed page */
	ulint			slot)		/* in: slot
						(0=first user record) */
{
	ut_ad(page_zip_simple_validate(page_zip));
	ut_ad(slot + 2 < page_dir_get_n_heap((page_t*) page_zip->data));
	return(mach_read_from_2(page_zip->data + page_zip->size
			- PAGE_ZIP_DIR_SLOT_SIZE * slot));
}
/*****************************************************************
Write a given slot in the dense page directory. */
UNIV_INLINE
void
page_zip_dir_set(
/*==============*/
	const page_zip_des_t*	page_zip,	/* in: compressed page */
	ulint			slot,		/* in: slot
						(0=first user record) */
	ulint			offs)		/* in: offset, possibly
						ORed with
						PAGE_ZIP_DIR_SLOT_DEL or
						PAGE_ZIP_DIR_SLOT_OWNED */
{
	ut_ad(page_zip_simple_validate(page_zip));
	ut_ad(slot + 2 < page_dir_get_n_heap((page_t*) page_zip->data));
	mach_write_to_2(page_zip->data + page_zip->size
			- PAGE_ZIP_DIR_SLOT_SIZE * slot,
			offs);
}

/**************************************************************************
Ensure that enough space is available in the modification log.
If not, try to compress the page. */
UNIV_INLINE
ibool
page_zip_alloc(
/*===========*/
				/* out: TRUE if enough space is available */
	page_zip_des_t*	page_zip,/* in/out: compressed page;
				will only be modified if compression is needed
				and successful */
	const page_t*	page,	/* in: uncompressed page */
	ulint		size)	/* in: size of modification log entries */
{
	ulint	trailer_len = page_zip_dir_size(page_zip);

	ut_ad(page_zip_simple_validate(page_zip));
	ut_ad(size >= 3); /* modification log entries are >= 1+1+1 bytes */
	ut_ad(size < page_zip->size);

	if (size + page_zip->m_end + trailer_len < page_zip->size) {
		return(TRUE);
	}

	if (page_zip->m_start == page_zip->m_end) {
		/* The page has been freshly compressed, so
		recompressing it will not help. */
		return(FALSE);
	}

	return(page_zip_compress(page_zip, page));
}

/**************************************************************************
Determine if enough space is available in the modification log. */
UNIV_INLINE
ibool
page_zip_available(
/*===============*/
					/* out: TRUE if enough space
					is available */
	const page_zip_des_t*	page_zip,/* in: compressed page */
	ulint			size)	/* in: requested size of
					modification log entries */
{
	ulint	trailer_len = page_zip_dir_size(page_zip);

	ut_ad(page_zip_simple_validate(page_zip));
	ut_ad(size < page_zip->size);

	return(UNIV_LIKELY(
		size + page_zip->m_end + trailer_len < page_zip->size));
}

/**************************************************************************
Write data to the uncompressed header portion of a page.  The data must
already have been written to the uncompressed page. */
UNIV_INLINE
void
page_zip_write_header(
/*==================*/
	page_zip_des_t*	page_zip,/* in/out: compressed page */
	const byte*	str,	/* in: address on the uncompressed page */
	ulint		length)	/* in: length of the data */
{
	ulint	pos;

	ut_ad(buf_block_get_page_zip(buf_block_align((byte*)str)) == page_zip);
	ut_ad(page_zip_simple_validate(page_zip));

	pos = ut_align_offset(str, UNIV_PAGE_SIZE);

	ut_ad(pos < PAGE_DATA);

	memcpy(page_zip + pos, str, length);

	ut_ad(page_zip_validate(page_zip, str - pos));
}

#ifdef UNIV_MATERIALIZE
# undef UNIV_INLINE
# define UNIV_INLINE	UNIV_INLINE_ORIGINAL
#endif
