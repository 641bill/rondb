/******************************************************
The database buffer buf_pool

(c) 1995 Innobase Oy

Created 11/5/1995 Heikki Tuuri
*******************************************************/

#include "buf0flu.h"
#include "buf0lru.h"
#include "buf0rea.h"
#include "mtr0mtr.h"

/************************************************************************
Recommends a move of a block to the start of the LRU list if there is danger
of dropping from the buffer pool. NOTE: does not reserve the buffer pool
mutex. */
UNIV_INLINE
ibool
buf_block_peek_if_too_old(
/*======================*/
				/* out: TRUE if should be made younger */
	buf_block_t*	block)	/* in: block to make younger */
{
	return(buf_pool->freed_page_clock >= block->freed_page_clock
	       + 1 + (buf_pool->curr_size / 1024));
}

/*************************************************************************
Gets the current size of buffer buf_pool in bytes. */
UNIV_INLINE
ulint
buf_pool_get_curr_size(void)
/*========================*/
			/* out: size in bytes */
{
	return(buf_pool->curr_size * UNIV_PAGE_SIZE);
}

/************************************************************************
Gets the smallest oldest_modification lsn for any page in the pool. Returns
ut_dulint_zero if all modified pages have been flushed to disk. */
UNIV_INLINE
dulint
buf_pool_get_oldest_modification(void)
/*==================================*/
				/* out: oldest modification in pool,
				ut_dulint_zero if none */
{
	buf_block_t*	block;
	dulint		lsn;

	mutex_enter(&(buf_pool->mutex));

	block = UT_LIST_GET_LAST(buf_pool->flush_list);

	if (block == NULL) {
		lsn = ut_dulint_zero;
	} else {
		lsn = block->oldest_modification;
	}

	mutex_exit(&(buf_pool->mutex));

	return(lsn);
}

/***********************************************************************
Increments the buf_pool clock by one and returns its new value. Remember
that in the 32 bit version the clock wraps around at 4 billion! */
UNIV_INLINE
ulint
buf_pool_clock_tic(void)
/*====================*/
			/* out: new clock value */
{
#ifdef UNIV_SYNC_DEBUG
	ut_ad(mutex_own(&(buf_pool->mutex)));
#endif /* UNIV_SYNC_DEBUG */

	buf_pool->ulint_clock++;

	return(buf_pool->ulint_clock);
}

/*************************************************************************
Gets the state of a block. */
UNIV_INLINE
enum buf_block_state
buf_block_get_state(
/*================*/
					/* out: state */
	const buf_block_t*	block)	/* in: pointer to the control block */
{
	enum buf_block_state	state = block->state;

#ifdef UNIV_DEBUG
	switch (state) {
	case BUF_BLOCK_NOT_USED:
	case BUF_BLOCK_READY_FOR_USE:
	case BUF_BLOCK_FILE_PAGE:
	case BUF_BLOCK_MEMORY:
	case BUF_BLOCK_REMOVE_HASH:
		break;
	default:
		ut_error;
	}
#endif /* UNIV_DEBUG */

	return(state);
}
/*************************************************************************
Sets the state of a block. */
UNIV_INLINE
void
buf_block_set_state(
/*================*/
	buf_block_t*		block,	/* in/out: pointer to control block */
	enum buf_block_state	state)	/* in: state */
{
#ifdef UNIV_DEBUG
	enum buf_block_state	old_state	= buf_block_get_state(block);

	switch (old_state) {
	case BUF_BLOCK_NOT_USED:
		ut_a(state == BUF_BLOCK_READY_FOR_USE);
		break;
	case BUF_BLOCK_READY_FOR_USE:
		ut_a(state == BUF_BLOCK_MEMORY
		     || state == BUF_BLOCK_FILE_PAGE
		     || state == BUF_BLOCK_NOT_USED);
		break;
	case BUF_BLOCK_MEMORY:
		ut_a(state == BUF_BLOCK_NOT_USED);
		break;
	case BUF_BLOCK_FILE_PAGE:
		ut_a(state == BUF_BLOCK_NOT_USED
		     || state == BUF_BLOCK_REMOVE_HASH);
		break;
	case BUF_BLOCK_REMOVE_HASH:
		ut_a(state == BUF_BLOCK_MEMORY);
		break;
	}
#endif /* UNIV_DEBUG */
	block->state = state;
	ut_ad(buf_block_get_state(block) == state);
}
/*************************************************************************
Map a block to a file page. */
UNIV_INLINE
void
buf_block_set_file_page(
/*====================*/
	buf_block_t*		block,	/* in/out: pointer to control block */
	ulint			space,	/* in: tablespace id */
	ulint			page_no)/* in: page number */
{
	buf_block_set_state(block, BUF_BLOCK_FILE_PAGE);
	block->space = space;
	block->offset = page_no;
}

/*************************************************************************
Gets a pointer to the memory frame of a block. */
UNIV_INLINE
buf_frame_t*
buf_block_get_frame(
/*================*/
				/* out: pointer to the frame */
	buf_block_t*	block)	/* in: pointer to the control block */
{
	ut_ad(block);
	ut_ad(buf_block_get_state(block) != BUF_BLOCK_NOT_USED);
	ut_ad(buf_block_get_state(block) != BUF_BLOCK_FILE_PAGE
	      || (block->buf_fix_count > 0));

	return(block->frame);
}

/*************************************************************************
Gets the space id of a block. */
UNIV_INLINE
ulint
buf_block_get_space(
/*================*/
					/* out: space id */
	const buf_block_t*	block)	/* in: pointer to the control block */
{
	ut_ad(block);
	ut_a(buf_block_get_state(block) == BUF_BLOCK_FILE_PAGE);

	return(block->space);
}

/*************************************************************************
Gets the page number of a block. */
UNIV_INLINE
ulint
buf_block_get_page_no(
/*==================*/
					/* out: page number */
	const buf_block_t*	block)	/* in: pointer to the control block */
{
	ut_ad(block);
	ut_a(buf_block_get_state(block) == BUF_BLOCK_FILE_PAGE);

	return(block->offset);
}

/*************************************************************************
Gets the compressed page size of a block. */
UNIV_INLINE
ulint
buf_block_get_zip_size(
/*===================*/
					/* out: compressed page size, or 0 */
	const buf_block_t*	block)	/* in: pointer to the control block */
{
	return(block->page_zip.size);
}

/*************************************************************************
Gets the compressed page descriptor corresponding to an uncompressed page
if applicable. */
UNIV_INLINE
page_zip_des_t*
buf_block_get_page_zip(
/*===================*/
				/* out: compressed page descriptor, or NULL */
	buf_block_t*	block)	/* in: pointer to the control block */
{
	if (UNIV_LIKELY_NULL(block->page_zip.data)) {
		return(&block->page_zip);
	}

	return(NULL);
}

#if defined UNIV_DEBUG || defined UNIV_ZIP_DEBUG
/***********************************************************************
Gets the block to whose frame the pointer is pointing to. */
UNIV_INLINE
buf_block_t*
buf_block_align(
/*============*/
			/* out: pointer to block */
	byte*	ptr)	/* in: pointer to a frame */
{
	buf_block_t*	block;
	ulint		space_id, page_no;

	ptr = ut_align_down(ptr, UNIV_PAGE_SIZE);
	page_no = mach_read_from_4(ptr + FIL_PAGE_OFFSET);
	space_id = mach_read_from_4(ptr + FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID);

	block = buf_page_hash_get(space_id, page_no);
	ut_ad(block);
	ut_ad(block->frame == ptr);
	return(block);
}

/*************************************************************************
Gets the compressed page descriptor corresponding to an uncompressed page
if applicable. */
UNIV_INLINE
page_zip_des_t*
buf_frame_get_page_zip(
/*===================*/
			/* out: compressed page descriptor, or NULL */
	byte*	ptr)	/* in: pointer to the page */
{
	page_zip_des_t*	page_zip;
	mutex_enter(&buf_pool->mutex);
	page_zip = buf_block_get_page_zip(buf_block_align(ptr));
	mutex_exit(&buf_pool->mutex);
	return(page_zip);
}
#endif /* UNIV_DEBUG || UNIV_ZIP_DEBUG */

/**************************************************************************
Gets the space id, page offset, and byte offset within page of a
pointer pointing to a buffer frame containing a file page. */
UNIV_INLINE
void
buf_ptr_get_fsp_addr(
/*=================*/
	const void*	ptr,	/* in: pointer to a buffer frame */
	ulint*		space,	/* out: space id */
	fil_addr_t*	addr)	/* out: page offset and byte offset */
{
	const page_t*	page = ut_align_down((void*) ptr, UNIV_PAGE_SIZE);

	*space = mach_read_from_4(page + FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID);
	addr->page = mach_read_from_4(page + FIL_PAGE_OFFSET);
	addr->boffset = ut_align_offset(ptr, UNIV_PAGE_SIZE);
}

/**************************************************************************
Gets the hash value of the page the pointer is pointing to. This can be used
in searches in the lock hash table. */
UNIV_INLINE
ulint
buf_block_get_lock_hash_val(
/*========================*/
					/* out: lock hash value */
	const buf_block_t*	block)	/* in: block */
{
	return(block->lock_hash_val);
}

/************************************************************************
Allocates a buffer block. */
UNIV_INLINE
buf_block_t*
buf_block_alloc(
/*============*/
				/* out, own: the allocated block */
	ulint	zip_size)	/* in: compressed page size in bytes,
				or 0 if uncompressed tablespace */
{
	buf_block_t*	block;

	block = buf_LRU_get_free_block(zip_size);

	return(block);
}

/************************************************************************
Frees a buffer block which does not contain a file page. */
UNIV_INLINE
void
buf_block_free(
/*===========*/
	buf_block_t*	block)	/* in, own: block to be freed */
{
	mutex_enter(&(buf_pool->mutex));

	mutex_enter(&block->mutex);

	ut_a(buf_block_get_state(block) != BUF_BLOCK_FILE_PAGE);

	buf_LRU_block_free_non_file_page(block);

	mutex_exit(&block->mutex);

	mutex_exit(&(buf_pool->mutex));
}

/*************************************************************************
Copies contents of a buffer frame to a given buffer. */
UNIV_INLINE
byte*
buf_frame_copy(
/*===========*/
					/* out: buf */
	byte*			buf,	/* in: buffer to copy to */
	const buf_frame_t*	frame)	/* in: buffer frame */
{
	ut_ad(buf && frame);

	ut_memcpy(buf, frame, UNIV_PAGE_SIZE);

	return(buf);
}

/************************************************************************
Calculates a folded value of a file page address to use in the page hash
table. */
UNIV_INLINE
ulint
buf_page_address_fold(
/*==================*/
			/* out: the folded value */
	ulint	space,	/* in: space id */
	ulint	offset)	/* in: offset of the page within space */
{
	return((space << 20) + space + offset);
}

/************************************************************************
This function is used to get info if there is an io operation
going on on a buffer page. */
UNIV_INLINE
ibool
buf_page_io_query(
/*==============*/
				/* out: TRUE if io going on */
	buf_block_t*	block)	/* in: buf_pool block, must be bufferfixed */
{
	mutex_enter(&(buf_pool->mutex));

	ut_ad(buf_block_get_state(block) == BUF_BLOCK_FILE_PAGE);
	ut_ad(block->buf_fix_count > 0);

	if (block->io_fix != 0) {
		mutex_exit(&(buf_pool->mutex));

		return(TRUE);
	}

	mutex_exit(&(buf_pool->mutex));

	return(FALSE);
}

/************************************************************************
Gets the youngest modification log sequence number for a frame. Returns zero
if not a file page or no modification occurred yet. */
UNIV_INLINE
dulint
buf_block_get_newest_modification(
/*==============================*/
				/* out: newest modification to the page */
	buf_block_t*	block)	/* in: block containing the page frame */
{
	dulint		lsn;

	mutex_enter(&(buf_pool->mutex));

	if (buf_block_get_state(block) == BUF_BLOCK_FILE_PAGE) {
		lsn = block->newest_modification;
	} else {
		lsn = ut_dulint_zero;
	}

	mutex_exit(&(buf_pool->mutex));

	return(lsn);
}

/************************************************************************
Increments the modify clock of a frame by 1. The caller must (1) own the
buf_pool mutex and block bufferfix count has to be zero, (2) or own an x-lock
on the block. */
UNIV_INLINE
void
buf_block_modify_clock_inc(
/*=======================*/
	buf_block_t*	block)	/* in: block */
{
#ifdef UNIV_SYNC_DEBUG
	ut_ad((mutex_own(&(buf_pool->mutex)) && (block->buf_fix_count == 0))
	      || rw_lock_own(&(block->lock), RW_LOCK_EXCLUSIVE));
#endif /* UNIV_SYNC_DEBUG */

	UT_DULINT_INC(block->modify_clock);
}

/************************************************************************
Returns the value of the modify clock. The caller must have an s-lock
or x-lock on the block. */
UNIV_INLINE
dulint
buf_block_get_modify_clock(
/*=======================*/
				/* out: value */
	buf_block_t*	block)	/* in: block */
{
#ifdef UNIV_SYNC_DEBUG
	ut_ad(rw_lock_own(&(block->lock), RW_LOCK_SHARED)
	      || rw_lock_own(&(block->lock), RW_LOCK_EXCLUSIVE));
#endif /* UNIV_SYNC_DEBUG */

	return(block->modify_clock);
}

#ifdef UNIV_SYNC_DEBUG
/***********************************************************************
Increments the bufferfix count. */
UNIV_INLINE
void
buf_block_buf_fix_inc_debug(
/*========================*/
	buf_block_t*	block,	/* in: block to bufferfix */
	const char*	file,	/* in: file name */
	ulint		line)	/* in: line */
{
	ibool	ret;

	ret = rw_lock_s_lock_func_nowait(&(block->debug_latch), file, line);
	ut_a(ret);
	ut_a(mutex_own(&block->mutex));
	block->buf_fix_count++;
}
#else /* UNIV_SYNC_DEBUG */
/***********************************************************************
Increments the bufferfix count. */
UNIV_INLINE
void
buf_block_buf_fix_inc(
/*==================*/
	buf_block_t*	block)	/* in: block to bufferfix */
{
	block->buf_fix_count++;
}
#endif /* UNIV_SYNC_DEBUG */
/**********************************************************************
Returns the control block of a file page, NULL if not found. */
UNIV_INLINE
buf_block_t*
buf_page_hash_get(
/*==============*/
			/* out: block, NULL if not found */
	ulint	space,	/* in: space id */
	ulint	offset)	/* in: offset of the page within space */
{
	buf_block_t*	block;
	ulint		fold;

	ut_ad(buf_pool);
#ifdef UNIV_SYNC_DEBUG
	ut_ad(mutex_own(&(buf_pool->mutex)));
#endif /* UNIV_SYNC_DEBUG */

	/* Look for the page in the hash table */

	fold = buf_page_address_fold(space, offset);

	HASH_SEARCH(hash, buf_pool->page_hash, fold, block,
		    (block->space == space) && (block->offset == offset));
	ut_a(!block || buf_block_get_state(block) == BUF_BLOCK_FILE_PAGE);

	return(block);
}

/************************************************************************
Tries to get the page, but if file io is required, releases all latches
in mtr down to the given savepoint. If io is required, this function
retrieves the page to buffer buf_pool, but does not bufferfix it or latch
it. */
UNIV_INLINE
buf_block_t*
buf_page_get_release_on_io(
/*=======================*/
				/* out: pointer to the block, or NULL
				if not in buffer buf_pool */
	ulint	space,		/* in: space id */
	ulint	offset,		/* in: offset of the page within space
				in units of a page */
	buf_block_t* guess,	/* in: guessed block or NULL */
	ulint	rw_latch,	/* in: RW_X_LATCH, RW_S_LATCH,
				or RW_NO_LATCH */
	ulint	savepoint,	/* in: mtr savepoint */
	mtr_t*	mtr)		/* in: mtr */
{
	buf_block_t*	block;

	block = buf_page_get_gen(space, offset, rw_latch, guess,
				 BUF_GET_IF_IN_POOL,
				 __FILE__, __LINE__,
				 mtr);
	if (block != NULL) {

		return(block);
	}

	/* The page was not in the buffer buf_pool: release the latches
	down to the savepoint */

	mtr_rollback_to_savepoint(mtr, savepoint);

	buf_page_get(space, offset, RW_S_LATCH, mtr);

	/* When we get here, the page is in buffer, but we release
	the latches again down to the savepoint, before returning */

	mtr_rollback_to_savepoint(mtr, savepoint);

	return(NULL);
}

/************************************************************************
Decrements the bufferfix count of a buffer control block and releases
a latch, if specified. */
UNIV_INLINE
void
buf_page_release(
/*=============*/
	buf_block_t*	block,		/* in: buffer block */
	ulint		rw_latch,	/* in: RW_S_LATCH, RW_X_LATCH,
					RW_NO_LATCH */
	mtr_t*		mtr)		/* in: mtr */
{
	ut_ad(block);

	ut_a(buf_block_get_state(block) == BUF_BLOCK_FILE_PAGE);
	ut_a(block->buf_fix_count > 0);

	if (rw_latch == RW_X_LATCH && mtr->modifications) {
		mutex_enter(&buf_pool->mutex);
		buf_flush_note_modification(block, mtr);
		mutex_exit(&buf_pool->mutex);
	}

	mutex_enter(&block->mutex);

#ifdef UNIV_SYNC_DEBUG
	rw_lock_s_unlock(&(block->debug_latch));
#endif
	block->buf_fix_count--;

	mutex_exit(&block->mutex);

	if (rw_latch == RW_S_LATCH) {
		rw_lock_s_unlock(&(block->lock));
	} else if (rw_latch == RW_X_LATCH) {
		rw_lock_x_unlock(&(block->lock));
	}
}

#ifdef UNIV_SYNC_DEBUG
/*************************************************************************
Adds latch level info for the rw-lock protecting the buffer frame. This
should be called in the debug version after a successful latching of a
page if we know the latching order level of the acquired latch. */
UNIV_INLINE
void
buf_block_dbg_add_level(
/*====================*/
	buf_block_t*	block,	/* in: buffer page
				where we have acquired latch */
	ulint		level)	/* in: latching order level */
{
	sync_thread_add_level(&block->lock, level);
}
#endif /* UNIV_SYNC_DEBUG */
