-- source include/have_ndb.inc
-- source include/not_embedded.inc

CREATE TABLE t1 (
  a char(10) NOT NULL primary key,
  b int
) comment='NDB_TABLE=FULLY_REPLICATED=1' ENGINE=ndbcluster;

insert into t1 values
('1',1), ('2',2), ('3',3), ('4',4),
('5',5), ('6',6), ('7',7), ('8',8);

create temporary table counters_at_startup
select counter_name, sum(val) as val
from ndbinfo.counters
group by counter_name;

select * from t1 where a = '1';
select * from t1 where a = '2';
select * from t1 where a = '3';
select * from t1 where a = '4';
select * from t1 where a = '5';
select * from t1 where a = '6';
select * from t1 where a = '7';
select * from t1 where a = '8';

--sorted_result
select * from t1 where a in ('1', '2', '3', '4', '5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('2', '3', '4', '5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('3', '4', '5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('4', '5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('6', '7', '8');
--sorted_result
select * from t1 where a in ('7', '8');

select s1.counter_name, s2.val - s1.val as diff
from counters_at_startup s1,
     (select counter_name, sum(val) as val
      from ndbinfo.counters
      group by counter_name) s2
where s1.counter_name = s2.counter_name
  and ( s1.counter_name = 'LOCAL_READS' or s1.counter_name = 'READS' )
order by 1;
drop table counters_at_startup;

--let ndb_desc_opts= -d test t1
--source suite/ndb/include/ndb_desc_print.inc

## Create nodegroup for "new" nodes 3,4
--echo Creating nodegroup
--exec $NDB_MGM -e "create nodegroup 3,4" > /dev/null

alter table t1 algorithm=inplace, reorganize partition;

set global ndb_data_node_neighbour = 1;
create table c as select node_id, fragment_num, tot_frag_scans
  from `ndbinfo`.`operations_per_fragment`
  where fq_name = 'test/def/t1';
select count(*) from t1;
select distinct o.node_id
  from `ndbinfo`.`operations_per_fragment` o join c
  on o.node_id = c.node_id and o.fragment_num = c.fragment_num
  where fq_name = 'test/def/t1' and o.tot_frag_scans > c.tot_frag_scans;
drop table c;

set global ndb_data_node_neighbour = 2;
create table c as select node_id, fragment_num, tot_frag_scans
  from `ndbinfo`.`operations_per_fragment`
  where fq_name = 'test/def/t1';
select count(*) from t1;
select distinct o.node_id
  from `ndbinfo`.`operations_per_fragment` o join c
  on o.node_id = c.node_id and o.fragment_num = c.fragment_num
  where fq_name = 'test/def/t1' and o.tot_frag_scans > c.tot_frag_scans;
drop table c;

set global ndb_data_node_neighbour = 3;
create table c as select node_id, fragment_num, tot_frag_scans
  from `ndbinfo`.`operations_per_fragment`
  where fq_name = 'test/def/t1';
--sorted_result
select * from t1 where a = 1;
select distinct o.node_id
  from `ndbinfo`.`operations_per_fragment` o join c
  on o.node_id = c.node_id and o.fragment_num = c.fragment_num
  where fq_name = 'test/def/t1' and o.tot_frag_scans > c.tot_frag_scans;
drop table c;

set global ndb_data_node_neighbour = 4;
create table c as select node_id, fragment_num, tot_frag_scans
  from `ndbinfo`.`operations_per_fragment`
  where fq_name = 'test/def/t1';
--sorted_result
select * from t1;
select distinct o.node_id
  from `ndbinfo`.`operations_per_fragment` o join c
  on o.node_id = c.node_id and o.fragment_num = c.fragment_num
  where fq_name = 'test/def/t1' and o.tot_frag_scans > c.tot_frag_scans;
drop table c;

set global ndb_data_node_neighbour = 0;

select node_id, fragment_num, fixed_elem_count
from `ndbinfo`.`memory_per_fragment`
where fq_name = 'test/def/t1'
order by node_id, fragment_num;

create temporary table counters_at_startup
select counter_name, sum(val) as val
from ndbinfo.counters
group by counter_name;

select * from t1 where a = '1';
select * from t1 where a = '2';
select * from t1 where a = '3';
select * from t1 where a = '4';
select * from t1 where a = '5';
select * from t1 where a = '6';
select * from t1 where a = '7';
select * from t1 where a = '8';

--sorted_result
select * from t1 where a in ('1', '2', '3', '4', '5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('2', '3', '4', '5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('3', '4', '5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('4', '5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('5', '6', '7', '8');
--sorted_result
select * from t1 where a in ('6', '7', '8');
--sorted_result
select * from t1 where a in ('7', '8');

select s1.counter_name, s2.val - s1.val as diff
from counters_at_startup s1,
     (select counter_name, sum(val) as val
      from ndbinfo.counters
      group by counter_name) s2
where s1.counter_name = s2.counter_name
  and ( s1.counter_name = 'LOCAL_READS' or s1.counter_name = 'READS' )
order by 1;
drop table counters_at_startup;

--let ndb_desc_opts= -d test t1
--source suite/ndb/include/ndb_desc_print.inc

## Create nodegroup for "new" nodes 5,6
--echo Creating nodegroup
--exec $NDB_MGM -e "create nodegroup 5,6" > /dev/null

## Create nodegroup for "new" nodes 7,8
--echo Creating nodegroup
--exec $NDB_MGM -e "create nodegroup 7,8" > /dev/null

alter table t1 algorithm=inplace, reorganize partition;

select node_id, fragment_num, fixed_elem_count
from `ndbinfo`.`memory_per_fragment`
where fq_name = 'test/def/t1'
order by node_id, fragment_num;

drop table t1;
