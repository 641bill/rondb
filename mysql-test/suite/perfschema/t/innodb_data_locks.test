drop table if exists t1_min;
drop table if exists t1_max;
drop table if exists t1_part;
drop table if exists t1_subpart;

create table t1_min(
  c01 TINYINT,
  c02 TINYINT UNSIGNED,
  c03 SMALLINT,
  c04 SMALLINT UNSIGNED,
  c05 MEDIUMINT,
  c06 MEDIUMINT UNSIGNED,
  c07 INT,
  c08 INT UNSIGNED,
  c09 BIGINT,
  c10 BIGINT UNSIGNED,
  PRIMARY KEY(c01, c02, c03, c04, c05, c06, c07, c08, c09, c10)
) ENGINE=INNODB;

create table t1_max(
  c01 TINYINT,
  c02 TINYINT UNSIGNED,
  c03 SMALLINT,
  c04 SMALLINT UNSIGNED,
  c05 MEDIUMINT,
  c06 MEDIUMINT UNSIGNED,
  c07 INT,
  c08 INT UNSIGNED,
  c09 BIGINT,
  c10 BIGINT UNSIGNED,
  PRIMARY KEY(c01, c02, c03, c04, c05, c06, c07, c08, c09, c10)
) ENGINE=INNODB;

create table t1_part(
  a int,
  b int,
  c int,
  PRIMARY KEY(a, b, c)
) ENGINE=INNODB PARTITION BY HASH(a) PARTITIONS 4;

create table t1_subpart(
  a int,
  b int,
  c int,
  PRIMARY KEY (a, b, c)
) ENGINE=INNODB
  PARTITION BY RANGE( a )
    SUBPARTITION BY HASH( b ) (
        PARTITION p0 VALUES LESS THAN (1990) (
            SUBPARTITION s0,
            SUBPARTITION s1
        ),
        PARTITION p1 VALUES LESS THAN (2000) (
            SUBPARTITION s2,
            SUBPARTITION s3
        ),
        PARTITION p2 VALUES LESS THAN MAXVALUE (
            SUBPARTITION s4,
            SUBPARTITION s5
        )
  );

insert into t1_min values
(-128, 0,
 -32768, 0,
 -8388608, 0,
 -2147483648, 0,
 -9223372036854775808, 0);

insert into t1_max values
(127, 255,
 32767, 65535,
 8388607, 16777215,
 2147483647, 4294967295,
 9223372036854775807, 18446744073709551615);

insert into t1_part values (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4);
insert into t1_subpart values (1, 1, 1), (2, 2, 2), (3, 3, 3), (4, 4, 4);

-- connect (con_lock,localhost,root,,)
-- connect (con_min_trylock,localhost,root,,)
-- connect (con_max_trylock,localhost,root,,)
-- connect (con_min_tryinsert,localhost,root,,)
-- connect (con_max_tryinsert,localhost,root,,)
-- connect (con_trypart,localhost,root,,)
-- connect (con_trysubpart,localhost,root,,)
-- connect (con_monitor,localhost,root,,)

-- connection con_lock
SET autocommit=0;
select * from t1_min for update;
select * from t1_max for update;
select * from t1_part for update;
select * from t1_subpart for update;

-- connection con_min_trylock
-- send
select * from t1_min for update;

-- connection default
let $wait_condition= SELECT COUNT(*)>=1 FROM performance_schema.data_locks
  where OBJECT_NAME='t1_min' and LOCK_STATUS='WAITING';
--source include/wait_condition.inc

-- connection con_max_trylock
-- send
select * from t1_max for update;

-- connection default
let $wait_condition= SELECT COUNT(*)>=1 FROM performance_schema.data_locks
  where OBJECT_NAME='t1_max' and LOCK_STATUS='WAITING';
--source include/wait_condition.inc

-- connection con_min_tryinsert
-- send
insert into t1_min values (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

-- connection default
let $wait_condition= SELECT COUNT(*)>=2 FROM performance_schema.data_locks
  where OBJECT_NAME='t1_min' and LOCK_STATUS='WAITING';
--source include/wait_condition.inc

-- connection con_max_tryinsert
-- send
insert into t1_max values (1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

-- connection default
let $wait_condition= SELECT COUNT(*)>=2 FROM performance_schema.data_locks
  where OBJECT_NAME='t1_max' and LOCK_STATUS='WAITING';
--source include/wait_condition.inc

-- connection con_trypart
-- send
select * from t1_part for update;

-- connection default
let $wait_condition= SELECT COUNT(*)>=1 FROM performance_schema.data_locks
  where OBJECT_NAME='t1_part' and LOCK_STATUS='WAITING';
--source include/wait_condition.inc

-- connection con_trysubpart
-- send
select * from t1_subpart for update;

-- connection default
let $wait_condition= SELECT COUNT(*)>=1 FROM performance_schema.data_locks
  where OBJECT_NAME='t1_subpart' and LOCK_STATUS='WAITING';
--source include/wait_condition.inc

-- connection con_monitor

# Debug
# select * from performance_schema.data_locks;
# select * from performance_schema.data_lock_waits;

select
  ENGINE,
  OBJECT_SCHEMA, OBJECT_NAME,
  PARTITION_NAME, SUBPARTITION_NAME, INDEX_NAME,
  LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA
  from performance_schema.data_locks
  order by OBJECT_SCHEMA, OBJECT_NAME,
  PARTITION_NAME, SUBPARTITION_NAME, INDEX_NAME,
  LOCK_TYPE, LOCK_MODE, LOCK_STATUS, LOCK_DATA;


# Basic integrity

select ENGINE, ENGINE_LOCK_ID, ENGINE_TRANSACTION_ID
  from performance_schema.data_locks
  where (ENGINE = "INNODB")
    and (ENGINE_TRANSACTION_ID not in
      (select trx_id from information_schema.innodb_trx));

-- vertical_results
select
  dl.ENGINE,
  dl.OBJECT_SCHEMA,
  dl.OBJECT_NAME,
  dl.PARTITION_NAME,
  dl.SUBPARTITION_NAME,
  dl.INDEX_NAME,
  dl.LOCK_TYPE,
  dl.LOCK_MODE,
  dl.LOCK_STATUS,
  dl.LOCK_DATA,

  it.trx_state,
  it.trx_weight,
  it.trx_query,
  it.trx_operation_state,
  it.trx_tables_in_use,
  it.trx_tables_locked,
  it.trx_lock_structs,
  it.trx_rows_locked,
  it.trx_rows_modified,
  it.trx_concurrency_tickets,
  it.trx_isolation_level,
  it.trx_unique_checks,
  it.trx_foreign_key_checks,
  it.trx_last_foreign_key_error,
  it.trx_adaptive_hash_latched,
  it.trx_adaptive_hash_timeout,
  it.trx_is_read_only,
  it.trx_autocommit_non_locking

  from performance_schema.data_locks dl inner join information_schema.innodb_trx it
    on dl.ENGINE_TRANSACTION_ID = it.TRX_ID
  order by ENGINE,
           OBJECT_SCHEMA, OBJECT_NAME,
           PARTITION_NAME, SUBPARTITION_NAME, INDEX_NAME,
           trx_query, lock_status, LOCK_DATA;

-- horizontal_results

-- connection default

-- disconnect con_lock
-- disconnect con_min_trylock
-- disconnect con_max_trylock
-- disconnect con_min_tryinsert
-- disconnect con_max_tryinsert
-- disconnect con_trypart
-- disconnect con_trysubpart
-- disconnect con_monitor

drop table t1_min;
drop table t1_max;
drop table t1_part;
drop table t1_subpart;

--echo
--echo Bug #28176805  PERFORMANCE_SCHEMA.DATA_LOCKS.LOCK_MODE
--echo DOES NOT RECOGNIZE LOCK_REC_NOT_GAP
--echo

# This test attempts to demonstrate various modes of locking

CREATE TABLE t1 (id INT PRIMARY KEY) Engine=InnoDB;
INSERT INTO t1 VALUES (0),(10),(20),(30);
CREATE TABLE t2 (id INT PRIMARY KEY AUTO_INCREMENT, val INT) Engine=InnoDB;

--connect (C1, localhost, root,,)
--connect (C2, localhost, root,,)
--connect (C3, localhost, root,,)
--connect (C4, localhost, root,,)

--connection C1
  BEGIN;
  # table IS
  # S
  SELECT * FROM t1 WHERE id=10 FOR SHARE;
  # table IX
  # X,REC_NOT_GAP
  INSERT INTO t1 VALUES (5);
  # S,GAP
  SELECT * FROM t1 WHERE id=25 FOR SHARE;
  # X,GAP
  SELECT * FROM t1 WHERE id=22 FOR UPDATE;
  # S,REC_NOT_GAP
  SELECT * FROM t1 where id>=10 and id<=20 FOR SHARE;
  # X
  SELECT * FROM t1 WHERE id>20 FOR UPDATE;

--connection C2
  BEGIN;
  SET DEBUG_SYNC = 'lock_wait_will_wait SIGNAL C2_will_wait';
  # X,GAP,INSERT_INTENTION
  --send INSERT INTO t1 VALUES (21)

--connection C3
  SET DEBUG_SYNC = 'now WAIT_FOR C2_will_wait';
  BEGIN;
  SHOW VARIABLES LIKE 'innodb_autoinc_lock_mode';
  SET DEBUG_SYNC = 'lock_wait_will_wait SIGNAL C3_will_wait';
  # AUTO_INC
  --send INSERT INTO t2 (val) SELECT id FROM t1 WHERE id>=0 AND id< 10;

--connection C4
  SET DEBUG_SYNC = 'now WAIT_FOR C3_will_wait';
  BEGIN;
  SET DEBUG_SYNC = 'lock_wait_will_wait SIGNAL C4_will_wait';
  # X,INSERT_INTENTION
  --send INSERT INTO t1 VALUES (35)

--connection default
  SET DEBUG_SYNC = 'now WAIT_FOR C4_will_wait';

  # We need to sort results so they are repeatable.
  # However Bug #28176910 causes ORDER BY to spoil the content of
  # result table if used directly in a query.
  # For now we simply hope for determinism.
    SELECT
      object_name,
      index_name,
      lock_type,
      lock_mode,
      lock_status,
      lock_data
    FROM performance_schema.data_locks;


--connection C1
  ROLLBACK;
--connection C2
  --reap
  ROLLBACK;
--connection C3
  --reap
  ROLLBACK;
--connection C4
  --reap
  ROLLBACK;

--connection default
--disconnect C1
--disconnect C2
--disconnect C3
--disconnect C4
DROP TABLE t1;
DROP TABLE t2;