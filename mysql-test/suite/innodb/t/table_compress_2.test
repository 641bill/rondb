#------------------------------------------------------------------------------
# Purpose of test : Test transparent page level compression in the IO layer.
# wl7696: InnoDB: Transparent page compression
# Test checks
# - if hole punching is available (if not then skip test) 
# - create table and insert data
# - Check if compression is done
#------------------------------------------------------------------------------
--source include/not_embedded.inc
--source include/have_innodb.inc
--source include/no_valgrind_without_big.inc

# # Avoid CrashReporter popup on Mac
--source include/not_crashrep.inc

let $fpt= `select @@innodb_file_per_table`;
SET GLOBAL innodb_file_per_table=1;

let MYSQLD_DATADIR= `select @@datadir`;

--let $db= test
--let $i_s_table= information_schema.innodb_sys_tablespaces

### retrieve database page size, filesystem compression unit size
### (fs_block_size), and OSD version of the same, they must agree
--let DB_PAGE_SIZE=`SELECT @@innodb_page_size`
eval CREATE TABLE $db.tc_no_comp (c INTEGER);
--let FS_BLOCK_SIZE=`SELECT fs_block_size FROM $i_s_table WHERE name = '$db/tc_no_comp'`
eval DROP TABLE $db.tc_no_comp;
perl;
  use strict;
  use warnings;
  use English;
  use File::Spec::Functions qw(splitpath catfile);

  my $osd = 0;
  if ($OSNAME eq 'MSWin32') {
      eval('use Win32::API');

      my ($vol,$dir,$fil) = splitpath(catfile($ENV{'MYSQLD_DATADIR','dummy'}));
### vol is now C: like
      my $GetDiskFreeSpace = Win32::API->new(
        "kernel32", "GetDiskFreeSpace", 
        ['P','P','P','P','P'], 'N')
        or die('failed to create GetDiskFreeSpace object');
      my $Drive = "$vol\\\0";
      my $SecsPerCluster = pack ("I", 0);
      my $BytesPerSec = pack ("I", 0);
      my $FreeClusters = pack ("I", 0);
      my $TotClusters = pack ("I", 0);
      $GetDiskFreeSpace->Call($Drive, $SecsPerCluster, $BytesPerSec, 
        $FreeClusters, $TotClusters)
        or print("GetDiskFreeSpace $vol: ", 
          Win32::FormatMessage(Win32::GetLastError()));
      my $SPC = unpack ("I", $SecsPerCluster);
      my $BPS = unpack ("I", $BytesPerSec);
### NTFS compression unit size
### We assume NTFS, will have to do for now
      $osd = 16 * $SPC * $BPS;
  } else {
    my @l = stat($ENV{MYSQLD_DATADIR});
### filesystem block size
    $osd = $l[11];
  }
  $osd = 0
    unless (defined($osd) and $osd =~ /^[0-9]+$/);

  printf("I_S fs_block_size '%s' is different from OSD '%s', OS '%s'\n",
    $ENV{FS_BLOCK_SIZE}, $osd, $OSNAME)
    if ($ENV{FS_BLOCK_SIZE} > 0 and $osd > 0 and $ENV{FS_BLOCK_SIZE} != $osd);
EOF


### create zlib compressed table and check if hole punching is supported
--let $table_zlib= tc_zlib
--disable_warnings
eval DROP TABLE IF EXISTS $db.$table_zlib;
eval CREATE TABLE $db.$table_zlib (t LONGTEXT) COMPRESSION='zlib';
--let COMPR_ZIP_WARN= `SHOW WARNINGS`
--enable_warnings

perl;
  use strict;
  my $no_holes = ($ENV{COMPR_ZIP_WARN} =~ /Punch hole not supported/)? 1 : 0;
### we do not expect any other warning
  printf("Unexpected warning: %s\n",$ENV{COMPR_ZIP_WARN})
    if (not $no_holes and $ENV{COMPR_ZIP_WARN} ne '');
  open(DHF,">$ENV{'MYSQLD_DATADIR'}/tc.inc");
  printf DHF "let \$no_holes= %s;\n",$no_holes;
  close(DHF);
EOF
--source $MYSQLD_DATADIR/tc.inc
--remove_file $MYSQLD_DATADIR/tc.inc
if ($no_holes)
{
  eval DROP TABLE IF EXISTS $db.$table_zlib;
  eval SET GLOBAL innodb_file_per_table=$fpt;
  skip needs DATADIR on fs that supports hole punching, or innodb_page_size is too small;
}

### if we are here we can expect hole punching.
### If block and page sizes disagree with it, it is an error
perl;
  use strict;
  printf(
 "Database page size is too small but a compressed table was created\n".
 "  innodb_page_size '%s', fs_block_size '%s'\n",
    $ENV{DB_PAGE_SIZE}, $ENV{FS_BLOCK_SIZE})
    if ($ENV{FS_BLOCK_SIZE} > 0
        and 2*$ENV{FS_BLOCK_SIZE} > $ENV{DB_PAGE_SIZE});
EOF

### create lz4 compressed tables
--let $table_lz4= tc_lz4
--disable_warnings
eval DROP TABLE IF EXISTS $db.$table_lz4;
--enable_warnings

eval CREATE TABLE $db.$table_lz4 (t LONGTEXT) COMPRESSION='lz4';

eval INSERT INTO $db.$table_zlib VALUES (REPEAT('z',142857));

eval INSERT INTO $db.$table_lz4 VALUES (REPEAT('4',142857));

COMMIT;

--let COMPR_TABLES= $db/$table_zlib,$db/$table_lz4

### check if the tables are compressed
--let COMPR_EXPECT= 1,1
--source include/innodb-compress-verify.inc

### cleanup
--disable_warnings
eval DROP TABLE IF EXISTS $db.$table_zlib;
eval DROP TABLE IF EXISTS $db.$table_lz4;
--enable_warnings
eval SET GLOBAL innodb_file_per_table=$fpt;
