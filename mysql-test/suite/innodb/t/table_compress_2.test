#------------------------------------------------------------------------------
# Purpose of test : Test transparent page level compression in the IO layer.
# wl7696: InnoDB: Transparent page compression
# Test checks
# - if hole punching is available (if not then skip test) 
# - create table and insert data
# - Check if compression is done
# Works with and without host support for lz4 compression
#------------------------------------------------------------------------------
--source include/not_embedded.inc
--source include/have_innodb.inc

# # Avoid CrashReporter popup on Mac
--source include/not_crashrep.inc

let $fpt= `select @@innodb_file_per_table`;
SET GLOBAL innodb_file_per_table=1;

--error 0,1193
let $cdebug= `select @@innodb_compress_debug`;
### skip innodb_compress_debug=lz4 to avoid unnecessary overcomplication
if ($cdebug == lz4) {
  skip innodb_compress_debug is set to 'lz4';
}

let MYSQLD_DATADIR= `select @@datadir`;

--let $db= test
--let $i_s_table= information_schema.innodb_sys_tablespaces

### retrieve database page size, filesystem compression unit size
### (fs_block_size), and OSD version of the same, they must agree
--let DB_PAGE_SIZE=`SELECT @@innodb_page_size`
eval CREATE TABLE $db.wl7696_no_comp (c INTEGER);
--let FS_BLOCK_SIZE=`SELECT fs_block_size FROM $i_s_table WHERE name = '$db/wl7696_no_comp'`
eval DROP TABLE $db.wl7696_no_comp;
perl;
  use strict;
  use warnings;
  use English;
  use File::Spec::Functions qw(splitpath catfile);

  my $osd = 0;
  if ($OSNAME eq 'MSWin32') {
      eval('use Win32::API');

      my ($vol,$dir,$fil) = splitpath(catfile($ENV{'MYSQLD_DATADIR','dummy'}));
### vol is now C: like
      my $GetDiskFreeSpace = Win32::API->new(
        "kernel32", "GetDiskFreeSpace", 
        ['P','P','P','P','P'], 'N')
        or die('failed to create GetDiskFreeSpace object');
      my $Drive = "$vol\\\0";
      my $SecsPerCluster = pack ("I", 0);
      my $BytesPerSec = pack ("I", 0);
      my $FreeClusters = pack ("I", 0);
      my $TotClusters = pack ("I", 0);
      $GetDiskFreeSpace->Call($Drive, $SecsPerCluster, $BytesPerSec, 
        $FreeClusters, $TotClusters)
        or print("GetDiskFreeSpace $vol: ", 
          Win32::FormatMessage(Win32::GetLastError()));
      my $SPC = unpack ("I", $SecsPerCluster);
      my $BPS = unpack ("I", $BytesPerSec);
### NTFS compression unit size
### We assume NTFS, will have to do for now
      $osd = 16 * $SPC * $BPS;
  } else {
    my @l = stat($ENV{MYSQLD_DATADIR});
### filesystem block size
    $osd = $l[11];
  }
  $osd = 0
    unless (defined($osd) and $osd =~ /^[0-9]+$/);

  printf("I_S fs_block_size '%s' is different from OSD '%s', OS '%s'\n",
    $ENV{FS_BLOCK_SIZE}, $osd, $OSNAME)
    if ($ENV{FS_BLOCK_SIZE} > 0 and $osd > 0 and $ENV{FS_BLOCK_SIZE} != $osd);
EOF


### create zlib compressed table and check if hole punching is supported
--let $table_zlib= wl7696_zlib
--disable_warnings
eval DROP TABLE IF EXISTS $db.$table_zlib;
eval CREATE TABLE $db.$table_zlib (t LONGTEXT) COMPRESSION='zlib';
--let WL7696_ZIP_WARN= `SHOW WARNINGS`
--enable_warnings

perl;
  use strict;
  my $no_holes = ($ENV{WL7696_ZIP_WARN} =~ /Punch hole not supported/)? 1 : 0;
### we do not expect any other warning
  printf("Unexpected warning: %s\n",$ENV{WL7696_ZIP_WARN})
    if (not $no_holes and $ENV{WL7696_ZIP_WARN} ne '');
  open(DHF,">$ENV{'MYSQLD_DATADIR'}/wl7696.inc");
  printf DHF "let \$no_holes= %s;\n",$no_holes;
  close(DHF);
EOF
--source $MYSQLD_DATADIR/wl7696.inc
--remove_file $MYSQLD_DATADIR/wl7696.inc
if ($no_holes)
{
  eval DROP TABLE IF EXISTS $db.$table_zlib;
  eval SET GLOBAL innodb_file_per_table=$fpt;
  skip needs DATADIR on fs that supports hole punching, or innodb_page_size is too small;
}

### if we are here we can expect hole punching.
### If block and page sizes disagree with it, it is an error
perl;
  use strict;
  printf(
 "Database page size is too small but a compressed table was created\n".
 "  innodb_page_size '%s', fs_block_size '%s'\n",
    $ENV{DB_PAGE_SIZE}, $ENV{FS_BLOCK_SIZE})
    if ($ENV{FS_BLOCK_SIZE} > 0
        and 2*$ENV{FS_BLOCK_SIZE} > $ENV{DB_PAGE_SIZE});
EOF

### attempt to create lz4 compressed tables,
### they will only be created if lz4* compression is supported
--let $table_lz4= wl7696_lz4
--disable_warnings
eval DROP TABLE IF EXISTS $db.$table_lz4;
--enable_warnings

### further code should not assume lz4 table has been actually created
--error 0,1031
eval CREATE TABLE $db.$table_lz4 (t LONGTEXT) COMPRESSION='lz4';

eval INSERT INTO $db.$table_zlib VALUES (REPEAT('z',142857));

--error 0,1146
eval INSERT INTO $db.$table_lz4 VALUES (REPEAT('4',142857));

COMMIT;

eval FLUSH TABLES $db.$table_zlib WITH READ LOCK;
UNLOCK TABLES;

--error 0,1146
eval FLUSH TABLES $db.$table_lz4 WITH READ LOCK;

UNLOCK TABLES;

### check if the tables are compressed by comparing file size
### with allocated size.
### We also check the correctness of allocated size as reported by I_S.
--let $s1=`SELECT name,file_size,allocated_size FROM $i_s_table WHERE name LIKE '$db/$table_zlib'`
--let $s2=`SELECT name,file_size,allocated_size FROM $i_s_table WHERE name LIKE '$db/$table_lz4'`
--let WL7696_SIZES= $s1,$s2,$s3
--let WL7696_TABLES= $db/$table_zlib,$db/$table_lz4

perl;
  use strict;
  use File::Spec::Functions;
  use warnings;
  no warnings ('uninitialized');

  my @ltables = sort(split(/\s*,\s*/,$ENV{'WL7696_TABLES'}));

  my @lsizes = split(/\s*,\s*/,$ENV{'WL7696_SIZES'});
  my %hsizes;
  foreach (@lsizes) {
      next if (/^\s*$/);
      my @l = split(/\s+/,$_);
      $hsizes{$l[0]} = [$l[1],$l[2]];
  }

  my $r1 = 'is compressed, or does not exist';
  foreach (@ltables) {
      if (not exists($hsizes{$_})) {
          printf("%s %s\n",$_,$r1);
          next;
      }

      my $plt = $hsizes{$_};

### zlib compression is always available, cosmetically improve messages
      my $g1 = $r1;
      $g1 =~ s/,.*// if (/zlib/);

      if ($plt->[0] > $plt->[1]) {
          printf("%s %s\n",$_,$g1);
      } else {
          printf("%s is not compressed, file size '%s', allocated size '%s'\n",
            $_,$plt->[0],$plt->[1]);
      }
  }

EOF

### cleanup
--disable_warnings
eval DROP TABLE IF EXISTS $db.$table_zlib;
eval DROP TABLE IF EXISTS $db.$table_lz4;
--enable_warnings
eval SET GLOBAL innodb_file_per_table=$fpt;
