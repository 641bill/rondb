--source include/have_innodb_16k.inc
--source include/big_test.inc
--source include/count_sessions.inc

# Exact capacity doesn't really matter, but we want it to be something
# small enough that the redo log produced during creation of the table
# will suffice to saturate it.
SELECT @@innodb_redo_log_capacity INTO @old_capacity;
# Let's start with small redo log files (320k each)
SET GLOBAL innodb_redo_log_capacity=10485760;

SET GLOBAL innodb_monitor_enable = log_lsn_current;

# Create table big enough, that modifying all of its rows requires approximately
# 100kb of redo, which is less than 10% of a single 1.3MB file.
CREATE TABLE t1(id BIGINT PRIMARY KEY, v BIGINT );
INSERT INTO t1 VALUES (1,1);
--let $i=0
while($i<10){
  INSERT INTO t1 SELECT (SELECT MAX(id) FROM t1)+id,v FROM t1;
    --inc $i
}

# prevent redo log files from being deleted
--connect(eater,localhost,root,,test)
  DO innodb_redo_log_consumer_register();

--connection default

# Verify that indeed an UPDATE of all rows requires approx 100k
# This also serves to create at least 2 x 320kb files, which is helpful, because
# we soon will want to reach a state where there is exactly one file of size
# 320kb, which is easiest if we can truncated to the boundary between two such
# files.
--let $i=0
while($i<10){
  SELECT `COUNT` FROM INFORMATION_SCHEMA.INNODB_METRICS
    WHERE NAME = 'log_lsn_current' INTO @lsn_before;
  UPDATE t1 SET v=v+1;
  SELECT `COUNT` FROM INFORMATION_SCHEMA.INNODB_METRICS
    WHERE NAME = 'log_lsn_current' INTO @lsn_after;
  #SELECT (@lsn_after - @lsn_before) BETWEEN 90000 AND 100000;
  SELECT (@lsn_after - @lsn_before) > 90000;
  --inc $i
}

# allow truncation till the boundary of last small file
--connection eater
  SELECT MAX(start_lsn) FROM performance_schema.innodb_redo_log_files
    INTO @base_lsn;
  #SELECT @base_lsn;
  DO innodb_redo_log_consumer_advance(@base_lsn);

--connection default

SET GLOBAL innodb_redo_log_capacity=10485760 * 4;
# 10485760*4 / 32 = 1310720  = 1.3 MB per file

# let's move out from the small file, so that at least one big file is created
# 4*90kb > 320kb
UPDATE t1 SET v=v+1;
UPDATE t1 SET v=v+1;
UPDATE t1 SET v=v+1;
UPDATE t1 SET v=v+1;

# A 10% margin is thus 130kb, which is a bit more than 100kb, so if we keep
# writing redo log in ~100kb increments, we should eventually hit the "10% near
# the end of file" margin, or 20% from the end, or whatever we want.

#SELECT * FROM performance_schema.innodb_redo_log_files;
SELECT MAX(end_lsn-start_lsn) FROM performance_schema.innodb_redo_log_files
  INTO @lsns_per_file;
#SELECT @lsns_per_file;

# Our goal is to have a situation:
# 1 x 320 KB
# 31 x 1.3 MB
# the write cursor is more than 10% of 1.3MB from the end of the last file.
# Say, between 80% and 90%.
SELECT 31-COUNT(*) FROM performance_schema.innodb_redo_log_files
  WHERE (end_lsn-start_lsn) = @lsns_per_file INTO @files_to_create;
#SELECT @files_to_create;

SELECT MAX(end_lsn) FROM performance_schema.innodb_redo_log_files
  INTO @last_file_lsn;
#SELECT @last_file_lsn;

SELECT @last_file_lsn+@files_to_create*@lsns_per_file INTO @stop_lsn;
#SELECT @stop_lsn;
#--sleep 4
--echo # Produce data until we get "20% close to end of 32rd file"
--disable_query_log
while(`SELECT COUNT < @stop_lsn - 130867*2
        FROM INFORMATION_SCHEMA.INNODB_METRICS
        WHERE NAME = 'log_lsn_current'`){
  UPDATE t1 SET v=v+1;
}
--enable_query_log
#SELECT `COUNT` FROM INFORMATION_SCHEMA.INNODB_METRICS
#  WHERE NAME = 'log_lsn_current';
#SELECT * FROM performance_schema.innodb_redo_log_files;
#--sleep 4
--echo # Now switch to small files again:
SET GLOBAL innodb_redo_log_capacity=10485760;
--echo # Write just enough to cross the 10% (of a small file!) from the end
--disable_query_log
while(`SELECT COUNT < @stop_lsn - 32768
        FROM INFORMATION_SCHEMA.INNODB_METRICS
        WHERE NAME = 'log_lsn_current'`){
  UPDATE t1 SET v=v+1 WHERE id MOD 4 = 1;
}
--enable_query_log
#SELECT `COUNT` FROM INFORMATION_SCHEMA.INNODB_METRICS
#  WHERE NAME = 'log_lsn_current';
#SELECT * FROM performance_schema.innodb_redo_log_files;
#--sleep 4
--echo # Now switch to big files again:
SET GLOBAL innodb_redo_log_capacity=10485760*4;
# wait for crash
--sleep 5

# Clean up
--disconnect eater
DROP TABLE t1;
SET GLOBAL innodb_redo_log_capacity=@old_capacity;
--source include/innodb_monitor_restore.inc
--source include/wait_until_count_sessions.inc
