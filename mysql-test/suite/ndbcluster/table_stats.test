--source include/have_ndb.inc

--echo # ###################################################################
--echo # Show that local table stats are correctly reflecting number of
--echo # records in table at failure to insert, both with and without trans
--echo # - in particular this shows how the "uncomitted rows" value in Thd_ndb
--echo #   is handled
CREATE TABLE t1 (
  a int PRIMARY KEY,
  b varchar(255)
) ENGINE = NDB;
INSERT INTO t1 VALUES (1, "this is in the way");
SELECT COUNT(*) as "count should be 1" FROM t1;

# Autocommit, one uncommitted row when failure occurs
--error ER_DUP_ENTRY
INSERT INTO t1 VALUES (1, "duplicate key");
SELECT COUNT(*) as "count should still be 1" FROM t1;

# Autocommit, three uncommitted rows when failure occurs
--error ER_DUP_ENTRY
INSERT INTO t1 VALUES
  (2, "val2"), (3, "val3"), (4, "val4"),
  (1, "duplicate key, 3 uncommitted");
SELECT COUNT(*) as "count should still be 1" FROM t1;

# Transaction, one uncommitted row when failure occurs
BEGIN;
  --error ER_DUP_ENTRY
  INSERT INTO t1 VALUES (1, "duplicate key, inside transaction");
  SELECT COUNT(*) as "count should still be 1" FROM t1;
COMMIT;
SELECT COUNT(*) as "count should still be 1" FROM t1;

# Transaction, three uncommitted rows when failure occurs
BEGIN;
  # Add three uncommitted to trans
  INSERT INTO t1 VALUES
    (2, "val2"), (3, "val3"), (4, "val4");
  SELECT COUNT(*) as "count should be 4" FROM t1;

  --error ER_DUP_ENTRY
  INSERT INTO t1 VALUES (1, "duplicate key, inside transaction, 3 uncommitted");
  SELECT COUNT(*) as "count should still be 1, whole trans aborted" FROM t1;
COMMIT;
SELECT COUNT(*) as "count should still be 1" FROM t1;

# Transaction, one uncommitted row when failure occurs, rollback
BEGIN;
  --error ER_DUP_ENTRY
  INSERT INTO t1 VALUES (1, "duplicate key, inside transaction");
  SELECT COUNT(*) as "count should still be 1" FROM t1;
ROLLBACK;
SELECT COUNT(*) as "count should still be 1" FROM t1;

# Transaction, three uncommitted rows when failure occurs, rollback
BEGIN;
  # Add three uncommitted to trans
  INSERT INTO t1 VALUES
    (2, "val2"), (3, "val3"), (4, "val4");
  SELECT COUNT(*) as "count should be 4" FROM t1;

  --error ER_DUP_ENTRY
  INSERT INTO t1 VALUES (1, "duplicate key, inside transaction, 3 uncommitted");
  SELECT COUNT(*) as "count should still be 1, whole trans aborted" FROM t1;
ROLLBACK;
SELECT COUNT(*) as "count should still be 1" FROM t1;


# Transaction, four uncommitted rows in other table when failure occurs
CREATE TABLE t2 (
  a int PRIMARY KEY,
  b varchar(255)
) ENGINE = NDB;
INSERT INTO t2 VALUES
  (10, "val10"), (12, "val12"), (13, "val13"), (14, "val14"), (15, "val15");
BEGIN;
  # Add four uncommitted to other table
  INSERT INTO t2 VALUES (1, "val1"), (2, "val2"), (3, "val3"), (4, "val4");
  SELECT COUNT(*) as "count should be 9" FROM t2;

  --error ER_DUP_ENTRY
  INSERT INTO t1 VALUES (1, "duplicate key, inside transaction");
  SELECT COUNT(*) as "count should still be 1" FROM t1;

  # Check count for other table
  SELECT COUNT(*) as "count should be 5, trans aborted" FROM t2;
COMMIT;
SELECT COUNT(*) as "count should still be 1" FROM t1;
SELECT COUNT(*) as "count should be 5" FROM t2;
DROP TABLE t2;

DROP TABLE t1;
