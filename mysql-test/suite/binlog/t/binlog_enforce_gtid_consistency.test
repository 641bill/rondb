# ==== Purpose ====
#
# Test that GTID-consistency violations generate warnings or errors,
# or pass with success, as expected.
#
# Generally, the following statement types are considered to be GTID
# consistency violations:
#
#  1. DML statements that mix non-transactional updates with
#     transactional updates. (Exception: non-transactional *temporary*
#     tables do not count, in case the statement is logged in row
#     format.)
#
#  2. Transactions that use non-transactional tables after having used
#     transactional tables. (Exception: non-transactional *temporary*
#     tables do not count, in case the statement is logged in row
#     format.)
#
#  3. CREATE TABLE ... SELECT.
#
#  4. CREATE TEMPORARY TABLE or DROP TEMPORARY TABLE within a
#     transaction
#
# A GTID-violating statement can pass with success, generate a
# warning, or generate an error, according to the following rules:
#
#  1. If ENFORCE_GTID_CONSISTENCY=ON, or GTID_NEXT='UUID:NUMBER', or
#     (GTID_NEXT='AUTOMATIC' and GTID_MODE=ON or ON_PERMISSIVE),
#     generate an error.
#
#  2. Otherwise, if ENFORCE_GTID_CONSISTENCY=WARN, generate a warning.
#
#  3. Otherwise, statement should pass without warning or error.
#
# ==== Implementation ====
#
# Iterate over all values of enforce_gtid_consistency.
# Iterate over all values of gtid_mode.
# For each gtid_next in automatic, anonymus, and GTID:
#   source extra/binlog_tests/enforce_gtid_consistency.test
#
# extra/binlog_tests/enforce_gtid_consistency.test, in turn, sources
# three different files:
# extra/binlog/enforce_gtid_consistency_[temporary|create_select|trx_nontrx].test
# The "trx_nontrx" file is sourced twice: with
# binlog_direct_non_transactional_updates=0 and 1.
#
# Each of
# extra/binlog/enforce_gtid_consistency_[temporary|create_select|trx_nontrx].test
# contains a number of specific test scenarios. Each test scenario has
# a statement that will be tested. For some scenarios, the expectation
# is that the statement violates GTID consistency, for other scenarios
# the expectation si that the statement does not violate GTID
# consistency.  Each scenario sources
# extra/binlog_tests/enforce_gtid_consistency_statement.inc to execute
# the statement and verify that the outcome is as expected.
#
# ==== References ====
#
# WL#3584: Global Transaction Identifiers
# - Created the test.
# WL#7083: GTIDs: set gtid_mode=ON online
# - Rewrote the test to improve coverage and test new logic for
#   enforce_gtid_consistency.

# Iterates over all GTID_MODEs; not meaningful to run more than once.
--source include/not_gtid_enabled.inc

# This test uses ANONYMOUS_GTID_VIOLATING_TRANSACTION_COUNT and
# AUTOMATIC_GTID_VIOLATING_TRANSACTION_COUNT, which are only define in
# debug mode.
--source include/have_debug.inc

--source include/have_myisam.inc
--source include/have_innodb.inc
--let $rpl_gtid_utils= 1
--let $rpl_server_count= 1
--let $rpl_topology= none
--source include/rpl_init.inc

# Disable warnings from binlog_format-unsafe statements, since they
# confuses the logic for checking that a GTID-violation warning was
# generated.
SET @old_sql_notes= @@GLOBAL.SQL_NOTES;
SET GLOBAL SQL_NOTES= 0;
SET SESSION SQL_NOTES= 0;

CALL mtr.add_suppression('Statement violates GTID consistency:');
CALL mtr.add_suppression('Unsafe statement written to the binary log');

--let $assert_text= ENFORCE_GTID_CONSISTENCY should default to 0
--let $assert_cond= @@GLOBAL.ENFORCE_GTID_CONSISTENCY = "OFF"
--source include/assert.inc

--let $gtid_next_mask_mode= 1
--let $gtid_next_connection= default

# For enforce_gtid_consistency = 0, 1, 2.
--let $enforce_gtid_consistency= 0
while ($enforce_gtid_consistency < 3)
{
  --echo ############ ENFORCE_GTID_CONSISTENCY=$enforce_gtid_consistency ############
  eval SET GLOBAL ENFORCE_GTID_CONSISTENCY = $enforce_gtid_consistency;
  SELECT @@GLOBAL.ENFORCE_GTID_CONSISTENCY;

  # For gtid_mode = [3,] 2, 1, 0.
  # 3 is only used when enforce_gtid_consistncy=1.
  SET GLOBAL GTID_MODE = OFF_PERMISSIVE;
  SET GLOBAL GTID_MODE = ON_PERMISSIVE;
  if ($enforce_gtid_consistency != 1)
  {
    --let $gtid_mode= 2
  }
  if ($enforce_gtid_consistency == 1)
  {
    --let $gtid_mode= 3
    SET GLOBAL GTID_MODE = ON;
  }
  while ($gtid_mode >= 0)
  {
    --echo ******** GTID_MODE=$gtid_mode ********
    eval SET GLOBAL GTID_MODE = $gtid_mode;

    --echo ==== GTID_NEXT=AUTOMATIC ====
    --let $gtid_next= AUTOMATIC
    --let $violation_result= $enforce_gtid_consistency
    if ($gtid_mode >= 2)
    {
      --let $violation_result= 1
    }
    --source extra/binlog_tests/enforce_gtid_consistency.test

    if ($gtid_mode < 3)
    {
      --echo ==== GTID_NEXT=ANONYMOUS ====
      --let $gtid_next= ANONYMOUS
      --let $violation_result= $enforce_gtid_consistency
      --source extra/binlog_tests/enforce_gtid_consistency.test
    }
    if ($gtid_mode > 0)
    {
      --echo ==== GTID_NEXT=UUID:NUMBER ====
      --let $gtid_next= GTID
      --let $violation_result= 1
      --source extra/binlog_tests/enforce_gtid_consistency.test
    }

    --dec $gtid_mode
  }

  --inc $enforce_gtid_consistency
}

--connection server_1

SET GLOBAL ENFORCE_GTID_CONSISTENCY = OFF;
SET GLOBAL SQL_NOTES = @old_sql_notes;

--source include/rpl_end.inc
