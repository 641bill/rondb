include/master-slave.inc
Warnings:
Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
[connection master]
[connection slave]
CALL mtr.add_suppression("You need to use --log-bin to make --binlog-format work");
CALL mtr.add_suppression("The transaction owned GTID is already in the gtid_executed table");
SET @save_slave_parallel_workers= @@global.slave_parallel_workers;
SET @save_slave_parallel_type= @@global.slave_parallel_type;
SET @save_slave_preserve_commit_order= @@global.slave_preserve_commit_order;
SET GLOBAL slave_parallel_type = 'LOGICAL_CLOCK';
SET GLOBAL slave_parallel_workers= 8;
SET GLOBAL slave_preserve_commit_order= ON;
include/start_slave.inc
[connection master1]
SET @save_binlog_transaction_dependency_tracking= @@global.binlog_transaction_dependency_tracking;
SET @@global.binlog_transaction_dependency_tracking = COMMIT_ORDER;

# Check for ANALYZE TABLE

# Setup

[connection master]
CREATE TABLE t1 (c1 INT PRIMARY KEY) ENGINE = InnoDB; CREATE TABLE t2 (c1 INT PRIMARY KEY) ENGINE = InnoDB;;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t2 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t2 VALUES (1); COMMIT; BEGIN; INSERT INTO t2 VALUES (2); COMMIT; ANALYZE TABLE t1;;
Table	Op	Msg_type	Msg_text
test.t1	analyze	status	OK
[connection server_1]
BEGIN; INSERT INTO t2 VALUES (3); COMMIT; BEGIN; INSERT INTO t2 VALUES (4); COMMIT; BEGIN; INSERT INTO t2 VALUES (5); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t2 has 0 rows]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
truncate table t1; truncate table t2;;
include/sync_slave_sql_with_master.inc
include/rpl_connect.inc [creating master]

# Check for REPAIR TABLE

# Setup

[connection master]
CREATE TABLE t3(a INT PRIMARY KEY)Engine=MyISAM; INSERT INTO t3 VALUES(1),(2),(3);;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t2 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t2 VALUES (1); COMMIT; BEGIN; INSERT INTO t2 VALUES (2); COMMIT; SET TIMESTAMP = 100; REPAIR TABLE t3;;
Table	Op	Msg_type	Msg_text
test.t3	repair	status	OK
[connection server_1]
BEGIN; INSERT INTO t2 VALUES (3); COMMIT; BEGIN; INSERT INTO t2 VALUES (4); COMMIT; BEGIN; INSERT INTO t2 VALUES (5); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t2 has 2 rows]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
truncate table t1; truncate table t2; DROP TABLE t3;;
include/sync_slave_sql_with_master.inc
include/rpl_connect.inc [creating master]

# Check for OPTIMIZE TABLE

# Setup

[connection master]
CREATE TABLE t3 (c1 INT PRIMARY KEY) ENGINE = InnoDB; CREATE TABLE t4 (c1 INT PRIMARY KEY) ENGINE = InnoDB;;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t4 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t4 VALUES (1); COMMIT; BEGIN; INSERT INTO t4 VALUES (2); COMMIT; OPTIMIZE TABLE t3;;
Table	Op	Msg_type	Msg_text
test.t3	optimize	note	Table does not support optimize, doing recreate + analyze instead
test.t3	optimize	status	OK
[connection server_1]
BEGIN; INSERT INTO t4 VALUES (3); COMMIT; BEGIN; INSERT INTO t4 VALUES (4); COMMIT; BEGIN; INSERT INTO t4 VALUES (5); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t4 is empty]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
DROP TABLE t3; DROP TABLE t4;;
include/sync_slave_sql_with_master.inc
include/rpl_connect.inc [creating master]

# Check for RENAME TABLE

# Setup

[connection master]
INSERT INTO t1 VALUES (10);;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t2 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t2 VALUES (1); COMMIT; BEGIN; INSERT INTO t2 VALUES (2); COMMIT; RENAME TABLE t1 to t10;;
[connection server_1]
BEGIN; INSERT INTO t2 VALUES (3); COMMIT; BEGIN; INSERT INTO t2 VALUES (4); COMMIT; BEGIN; INSERT INTO t2 VALUES (5); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t2 is empty]
include/assert.inc [Verify table t1 exists]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
truncate table t2; DROP TABLE t10; CREATE TABLE t1 (c1 INT PRIMARY KEY) ENGINE = InnoDB;;
include/sync_slave_sql_with_master.inc

# Check for CREATE DATABASE and CREATE DATABASE IF NOT EXISTS

# Setup

[connection master]
INSERT INTO t1 VALUES (10);;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t1 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t1 VALUES (1); COMMIT; BEGIN; INSERT INTO t1 VALUES (2); COMMIT; CREATE DATABASE db1; CREATE DATABASE IF NOT EXISTS db2;;
[connection server_1]
BEGIN; INSERT INTO t2 VALUES (1); COMMIT; BEGIN; INSERT INTO t2 VALUES (2); COMMIT; BEGIN; INSERT INTO t2 VALUES (3); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t2 is empty]
include/assert.inc [Verify DATABASE db1 does not exist]
include/assert.inc [Verify DATABASE db2 does not exist]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
truncate table t1; truncate table t2; DROP DATABASE db1; DROP DATABASE db2;;
include/sync_slave_sql_with_master.inc

# Check for CREATE TABLESPACE

# Setup

[connection master]
INSERT INTO t1 VALUES (10);;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t1 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t1 VALUES (1); COMMIT; BEGIN; INSERT INTO t1 VALUES (2); COMMIT; CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd' Engine=InnoDB;;
[connection server_1]
BEGIN; INSERT INTO t2 VALUES (1); COMMIT; BEGIN; INSERT INTO t2 VALUES (2); COMMIT; BEGIN; INSERT INTO t2 VALUES (3); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t1 has one value]
include/assert.inc [Verify table t2 is empty]
include/assert.inc [Verify TABLESPACE does not exist]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
truncate table t1; truncate table t2; DROP TABLESPACE ts1;;
include/sync_slave_sql_with_master.inc

# Check for ALTER TABLESPACE

# Setup

[connection master]
INSERT INTO t1 VALUES (10); CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd' Engine=InnoDB; CREATE TABLE t11 (a INT, b INT) ENGINE = InnoDB TABLESPACE=ts1;;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t1 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t1 VALUES (1); COMMIT; BEGIN; INSERT INTO t1 VALUES (2); COMMIT; ALTER TABLESPACE ts1 RENAME TO ts11;;
[connection server_1]
BEGIN; INSERT INTO t2 VALUES (1); COMMIT; BEGIN; INSERT INTO t2 VALUES (2); COMMIT; BEGIN; INSERT INTO t2 VALUES (3); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t1 has one value]
include/assert.inc [Verify TABLESPACE ts1 exists]
include/assert.inc [Verify TABLESPACE ts11 does not exists]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
truncate table t1; truncate table t2; DROP TABLE t11;  DROP TABLESPACE ts11;;
include/sync_slave_sql_with_master.inc

# Check for DROP TABLESPACE

# Setup

[connection master]
INSERT INTO t1 VALUES (10); CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd' Engine=InnoDB;;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t1 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t1 VALUES (1); COMMIT; BEGIN; INSERT INTO t1 VALUES (2); COMMIT; DROP TABLESPACE ts1;;
[connection server_1]
BEGIN; INSERT INTO t2 VALUES (1); COMMIT; BEGIN; INSERT INTO t2 VALUES (2); COMMIT; BEGIN; INSERT INTO t2 VALUES (3); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t1 has one value]
include/assert.inc [Verify table t2 is empty]
include/assert.inc [Verify TABLESPACE exists]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
truncate table t1; truncate table t2;;
include/sync_slave_sql_with_master.inc

# Check for CREATE INDEX

# Setup

[connection master]
INSERT INTO t1 VALUES (10); CREATE TABLE t3 (col1 INT, col2 INT, INDEX func_index ((ABS(col1)))); INSERT INTO t3 VALUES(1,1);;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t1 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t1 VALUES (1); COMMIT; BEGIN; INSERT INTO t1 VALUES (2); COMMIT; CREATE INDEX idx1 ON t3 ((col1 + col2));;
[connection server_1]
BEGIN; INSERT INTO t2 VALUES (1); COMMIT; BEGIN; INSERT INTO t2 VALUES (2); COMMIT; BEGIN; INSERT INTO t2 VALUES (3); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t1 has one value]
include/assert.inc [Verify table t2 is empty]
include/assert.inc [Verify INDEX does not exist]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
truncate table t1; truncate table t2; DROP INDEX idx1 ON t3; DROP TABLE t3;;
include/sync_slave_sql_with_master.inc

# Check for DROP INDEX

# Setup

[connection master]
INSERT INTO t1 VALUES (10); CREATE TABLE t3 (col1 INT, col2 INT, INDEX func_index ((ABS(col1)))); INSERT INTO t3 VALUES(1,1); CREATE INDEX idx1 ON t3 ((col1 + col2));;
include/sync_slave_sql_with_master.inc

# Block slave sql applier threads

[connection slave]
BEGIN; INSERT INTO t1 VALUES (1);;
[connection slave]
[connection slave]

# Generate the transactions which can be applied in parallel on slave

[connection master]
# Adding debug point 'set_commit_parent_100' to @@GLOBAL.debug
BEGIN; INSERT INTO t1 VALUES (1); COMMIT; BEGIN; INSERT INTO t1 VALUES (2); COMMIT; DROP INDEX idx1 ON t3;;
[connection server_1]
BEGIN; INSERT INTO t2 VALUES (1); COMMIT; BEGIN; INSERT INTO t2 VALUES (2); COMMIT; BEGIN; INSERT INTO t2 VALUES (3); COMMIT;;
# Removing debug point 'set_commit_parent_100' from @@GLOBAL.debug

# Verify the transactions are ordered correctly on slave

[connection server_2]
include/assert.inc [Verify table t1 has one value]
include/assert.inc [Verify table t2 is empty]
include/assert.inc [Verify INDEX exists]
[connection slave]
include/assert.inc [Exactly 0 GTIDs should have been committed since last invocation]

# Rollback the first insert so that slave applier threads can
# unblock and proceed. Verify the transactions are applied.

[connection slave]
ROLLBACK;;
truncate table t1; truncate table t2; DROP TABLE t1,t2,t3;;
include/sync_slave_sql_with_master.inc

# Cleanup

[connection master1]
SET GLOBAL binlog_transaction_dependency_tracking=@save_binlog_transaction_dependency_tracking;
include/sync_slave_sql_with_master.inc
include/stop_slave.inc
SET GLOBAL slave_parallel_type=@save_slave_parallel_type;
SET GLOBAL slave_parallel_workers=@save_slave_parallel_workers;
SET GLOBAL slave_preserve_commit_order=@save_slave_preserve_commit_order;
include/start_slave.inc
include/rpl_end.inc
