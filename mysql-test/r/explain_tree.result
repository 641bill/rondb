set optimizer_switch='batched_key_access=off,block_nested_loop=off,mrr_cost_based=off';
CREATE TABLE t1 ( f1 INT );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t1 VALUES ( 2 );
INSERT INTO t1 VALUES ( 3 );
EXPLAIN FORMAT=tree SELECT * FROM t1;
EXPLAIN
-> Table scan on t1

DROP TABLE t1;
CREATE TABLE t1 ( f1 INT );
CREATE TABLE t2 ( f1 INT );
EXPLAIN FORMAT=tree INSERT INTO t2 SELECT * FROM t1;
EXPLAIN
-> Insert into t2
    -> Table scan on t1

DROP TABLE t1, t2;
CREATE TABLE t1 ( f1 INT );
CREATE TABLE t2 ( f2 INT );
EXPLAIN FORMAT=tree UPDATE t1, t2 SET f1=f1+2, f2=f2+1 WHERE f1 = f2;
EXPLAIN
-> Update t1, t2
    -> Nested loop inner join
        -> Table scan on t1
        -> Filter: (t2.f2 = t1.f1)
            -> Table scan on t2

DROP TABLE t1, t2;
CREATE TABLE t1 ( f1 INT );
CREATE TABLE t2 ( f2 INT );
EXPLAIN FORMAT=tree DELETE t1, t2 FROM t1, t2;
EXPLAIN
-> Delete from t1, t2
    -> Nested loop inner join
        -> Table scan on t1
        -> Table scan on t2

DROP TABLE t1, t2;
CREATE TABLE t1 ( f1 INT );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t1 VALUES ( 2 );
INSERT INTO t1 VALUES ( 3 );
EXPLAIN FORMAT=tree SELECT f1, (SELECT MIN(f1) FROM t1 i WHERE i.f1 > t1.f1) FROM t1;
EXPLAIN
-> Table scan on t1

Warnings:
Note	1276	Field or reference 'test.t1.f1' of SELECT #2 was resolved in SELECT #1
DROP TABLE t1;
CREATE TABLE t1 ( f1 INT PRIMARY KEY );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t1 VALUES ( 2 );
INSERT INTO t1 VALUES ( 3 );
EXPLAIN FORMAT=tree SELECT * FROM t1 ORDER BY f1 DESC;
EXPLAIN
-> Index scan on t1 using PRIMARY (reverse)

DROP TABLE t1;
CREATE TABLE t1 ( f1 INT, INDEX ( f1 ) );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t1 VALUES ( 2 );
INSERT INTO t1 VALUES ( 3 );
EXPLAIN FORMAT=tree SELECT SUM(f1) FROM t1;
EXPLAIN
-> Aggregate: sum(t1.f1)
    -> Index scan on t1 using f1

EXPLAIN FORMAT=tree SELECT f1 FROM t1 GROUP BY f1;
EXPLAIN
-> Group (no aggregates)
    -> Index scan on t1 using f1

EXPLAIN FORMAT=tree SELECT f1,COUNT(*) FROM t1 GROUP BY f1;
EXPLAIN
-> Group aggregate: count(0)
    -> Index scan on t1 using f1

DROP TABLE t1;
CREATE TABLE t1 ( f1 INT PRIMARY KEY );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t1 VALUES ( 2 );
INSERT INTO t1 VALUES ( 3 );
CREATE TABLE t2 ( f1 INT PRIMARY KEY );
INSERT INTO t2 SELECT * FROM t1;
EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN t2 ON t1.f1 = t2.f1 + 2 AND t2.f1 = 3;
EXPLAIN
-> Nested loop left join
    -> Index scan on t1 using PRIMARY
    -> Filter: (t1.f1 = <cache>((3 + 2)))
        -> Constant row from t2

DROP TABLE t1, t2;
CREATE TABLE t1 ( a INT );
CREATE TABLE t2 ( a INT );
CREATE TABLE t3 ( a INT, b INT );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t2 VALUES ( 3 );
INSERT INTO t3 VALUES ( 2, 0 );
EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN ( t2 LEFT JOIN t3 USING (a) ) ON t3.b IS NULL;
EXPLAIN
-> Nested loop left join
    -> Table scan on t1
    -> Filter: isnull(t3.b)
        -> Nested loop left join
            -> Table scan on t2
            -> Filter: (t3.a = t2.a)
                -> Table scan on t3

DROP TABLE t1, t2, t3;
CREATE TABLE t1 ( f1 INT PRIMARY KEY );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t1 VALUES ( 2 );
INSERT INTO t1 VALUES ( 3 );
CREATE TABLE t2 AS SELECT * FROM t1;
EXPLAIN FORMAT=tree SELECT * FROM t1 LEFT JOIN t2 USING (f1) WHERE t2.f1 IS NULL;
EXPLAIN
-> Filter: isnull(t2.f1)
    -> Nested loop anti-join
        -> Index scan on t1 using PRIMARY
        -> Filter: (t2.f1 = t1.f1)
            -> Table scan on t2

DROP TABLE t1, t2;
CREATE TABLE t1 ( f1 INT );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t1 VALUES ( 2 );
INSERT INTO t1 VALUES ( 3 );
EXPLAIN FORMAT=tree SELECT * FROM t1 ORDER BY f1 DESC;
EXPLAIN
-> Sort: t1.f1 DESC
    -> Table scan on t1

DROP TABLE t1;
CREATE TABLE t1 ( f1 INT PRIMARY KEY );
INSERT INTO t1 VALUES ( 1 );
INSERT INTO t1 VALUES ( 2 );
INSERT INTO t1 VALUES ( 3 );
EXPLAIN FORMAT=tree SELECT * FROM t1 WHERE f1 = ( SELECT MIN(f1) FROM t1 AS i WHERE i.f1 > t1.f1 );
EXPLAIN
-> Filter: (t1.f1 = (select #2))
    -> Index scan on t1 using PRIMARY
    -> Select #2 (subquery in condition; dependent)
        -> Aggregate: min(i.f1)
            -> Filter: (i.f1 > t1.f1)
                -> Index range scan on i (re-planned for each iteration)

Warnings:
Note	1276	Field or reference 'test.t1.f1' of SELECT #2 was resolved in SELECT #1
EXPLAIN FORMAT=tree SELECT * FROM t1 WHERE f1 > ( SELECT f1 FROM t1 LIMIT 1 );
EXPLAIN
-> Filter: (t1.f1 > (select #2))
    -> Index scan on t1 using PRIMARY
    -> Select #2 (subquery in condition; run only once)
        -> Limit: 1 row(s)
            -> Index scan on t1 using PRIMARY

DROP TABLE t1;
CREATE TABLE t1 (a INTEGER, b INTEGER);
INSERT INTO t1 VALUES (1,3), (2,4), (1,5),
(1,3), (2,1), (1,5), (1,7), (3,1),
(3,2), (3,1), (2,4);
EXPLAIN FORMAT=tree SELECT * FROM t1 WHERE a > 3 ORDER BY b;
EXPLAIN
-> Filter: (t1.a > 3)
    -> Sort: t1.bÂ (with hidden filter)
        -> Table scan on t1

DROP TABLE t1;
CREATE TABLE t1 (i INT);
EXPLAIN INSERT INTO t1 VALUES (10);
id	select_type	table	partitions	type	possible_keys	key	key_len	ref	rows	filtered	Extra
1	INSERT	t1	NULL	ALL	NULL	NULL	NULL	NULL	NULL	NULL	NULL
Warnings:
Note	1003	insert into `test`.`t1` values (10)
EXPLAIN FORMAT=tree INSERT INTO t1 VALUES (10);
EXPLAIN
<not executable by iterator executor>

DROP TABLE t1;
