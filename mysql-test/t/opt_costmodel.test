#
# Default values for cost constants (from the source code)
#
let $row_evaluate_cost= 0.2;
let $key_compare_cost= 0.1;
let $memory_temptable_create_cost= 2.0;
let $memory_temptable_row_cost= 0.2;
let $disk_temptable_create_cost= 40;
let $disk_temptable_row_cost= 1.0;
let $io_block_read_cost= 1.0;

--echo #
--echo # Bug#20443863 USE OF WORST_SEEKS IN FIND_BEST_REF() CAN LEAD TO
--echo #              WRONG QUERY PLAN
--echo #


CREATE TABLE t1 (
  i1 INTEGER,
  i2 INTEGER,
  i3 INTEGER,
  KEY(i1,i2)
) ENGINE=InnoDB;

INSERT INTO t1 VALUES (1, 1, 1), (1, 1, 1),(1, 1, 1),(1, 1, 1),
                      (2, 2, 1), (2, 2, 1),(2, 2, 1),(2, 2, 1),
                      (3, 3, 1), (3, 3, 1),(3, 3, 1),(3, 3, 1);

--disable_query_log
--disable_result_log
ANALYZE TABLE t1;
--enable_result_log
--enable_query_log

# worst_seeks is used for two cases: when the entire index is used and 
# when only a prefix of the index is used. Two get coverage for both cases,
# two almost identical queries are needed.

# Test query for case 1: the entire index is used
let query_1= SELECT i3 FROM t1 WHERE i1 = 1 AND i2 = 1;

# Test query for case 2: only a prefix of the index is used
let query_2= SELECT i3 FROM t1 WHERE i1 = 1 AND i3 = 1;

# Run the queries with default cost constants

# Create a user connection
connect (con1,localhost,root,,);
connection con1;

# Get cost estimates with default values
eval EXPLAIN FORMAT=JSON $query_1;
eval EXPLAIN FORMAT=JSON $query_2;

disconnect con1;
connection default;

# Double the value that the cost constants have:
# 1. Replace the NULL in the cost_value column with actual value

# Update server_cost:
eval UPDATE mysql.server_cost
     SET cost_value=$row_evaluate_cost
     WHERE cost_name="row_evaluate_cost";

eval UPDATE mysql.server_cost
     SET cost_value=$key_compare_cost
     WHERE cost_name="key_compare_cost";

eval UPDATE mysql.server_cost
     SET cost_value=$memory_temptable_create_cost
     WHERE cost_name="memory_temptable_create_cost";

eval UPDATE mysql.server_cost
     SET cost_value=$memory_temptable_row_cost
     WHERE cost_name="memory_temptable_row_cost";

eval UPDATE mysql.server_cost
     SET cost_value=$disk_temptable_create_cost
     WHERE cost_name="disk_temptable_create_cost";

eval UPDATE mysql.server_cost
     SET cost_value=$disk_temptable_row_cost
     WHERE cost_name="disk_temptable_row_cost";

# Update engine_cost:
eval UPDATE mysql.engine_cost
     SET cost_value=$io_block_read_cost
     WHERE cost_name="io_block_read_cost";

# 2. Multiply all cost constants by two
UPDATE mysql.server_cost
SET cost_value = 2 * cost_value;

UPDATE mysql.engine_cost
SET cost_value = 2 * cost_value;

# Validate cost constants
SELECT cost_name, cost_value FROM mysql.server_cost;
SELECT cost_name, cost_value FROM mysql.engine_cost;

FLUSH OPTIMIZER_COSTS;

# Re-run the queries with the new cost constants

# Create a user connection
connect (con1,localhost,root,,);
connection con1;

# The new cost estimates should be approximately the double compared to the
# first run
eval EXPLAIN FORMAT=JSON $query_1;
eval EXPLAIN FORMAT=JSON $query_2;

disconnect con1;
connection default;

# Reset cost constants
UPDATE mysql.server_cost
SET cost_value=DEFAULT;

UPDATE mysql.engine_cost
SET cost_value=DEFAULT;

FLUSH OPTIMIZER_COSTS;

DROP TABLE t1;
