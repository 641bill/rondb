--source include/have_null_audit_plugin.inc
--source include/not_embedded.inc
--source include/have_debug.inc

connection default;

--replace_regex /\.dll/.so/
eval INSTALL PLUGIN null_audit SONAME '$AUDIT_NULL';

--echo #
--echo # Bug #22136709: INFINITE RECURSION BY CALLING MY_MESSAGE FROM
--echo #   MYSQL_AUDIT_GENERAL_CLASS HANDLER

# Save the initial number of concurrent sessions
--source include/count_sessions.inc

SET @@GLOBAL.null_audit_event_order_check= "MYSQL_AUDIT_GENERAL_ERROR;;ABORT_RET";
SET @@GLOBAL.null_audit_abort_message= "Abort message.";

# 3 recursive my_message calls should not cause stack overrun
SET @@GLOBAL.null_audit_event_order_check_consume_ignore_count= 2;
--error ER_AUDIT_API_ABORT
connect(user1_con,localhost,wrong_root,);

# Infinite my_message calls cause stack overrun
SET @@GLOBAL.null_audit_event_order_check_consume_ignore_count= 10000;
--replace_result $MASTER_MYSOCK MASTER_SOCKET $MASTER_MYPORT MASTER_PORT
--disable_result_log
--error ER_STACK_OVERRUN_NEED_MORE
connect(user1_con,localhost,wrong_root,);
--enable_result_log

# Clean up global variables
SET @@GLOBAL.null_audit_event_order_check= NULL;
SET @@GLOBAL.null_audit_abort_message= NULL;
# Let's hope 10000 calls will overrun the stack frame
SET @@GLOBAL.null_audit_event_order_check_consume_ignore_count= 0;

--echo # test
connect(user1_con,localhost,root,);

SET @@null_audit_event_order_check= "MYSQL_AUDIT_GENERAL_ERROR;;ABORT_RET";
SET @@null_audit_abort_message= "Abort message.";
# Let's hope 10000 calls will overrun the stack frame
SET @@null_audit_event_order_check_consume_ignore_count= 10000;

--echo # Must not crash
--replace_regex /[0-9]+ byte[s]?/<NUMBER>/
--error ER_STACK_OVERRUN_NEED_MORE
SELECT 1 FROM mysql.fictional_table;

--echo # Clean up
connection default;
disconnect user1_con;

# Wait till we reached the initial number of concurrent sessions
--source include/wait_until_count_sessions.inc



--echo End of 5.7 tests

--echo # cleanup
UNINSTALL PLUGIN null_audit;
