/*****************************************************************************

Copyright (c) 2016, Oracle and/or its affiliates. All Rights Reserved.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA

*****************************************************************************/

/**************************************************//**
@file include/dict0dd.ic
Data dictionary access

Created  10/2016 Jimmy Yamg
*******************************************************/

#include "sql_table.h"
#include "dict0crea.h"

/** Parse a table name
@param[in]      tbl_name        table name including database and table name
@param[in,out]	dd_db_name	database name buffer to be filled
@param[in,out]	dd_tbl_name	table name buffer to be filled */
UNIV_INLINE
void
innobase_parse_tbl_name(
	const char*	tbl_name,
	char*		dd_db_name,
	char*		dd_tbl_name)
{
	char	db_buf[MAX_DATABASE_NAME_LEN + 1];
	char	tbl_buf[MAX_TABLE_NAME_LEN + 1];
	ulint	db_len = dict_get_db_name_len(tbl_name);

	ut_ad(db_len <= MAX_DATABASE_NAME_LEN);
	memcpy(db_buf, tbl_name, db_len);
	db_buf[db_len] = 0;
	memcpy(tbl_buf, tbl_name + db_len + 1,
	       strlen(tbl_name) - db_len - 1);
	tbl_buf[strlen(tbl_name) - db_len - 1] = 0;

	filename_to_tablename(db_buf, dd_db_name, MAX_DATABASE_NAME_LEN + 1);
	filename_to_tablename(tbl_buf, dd_tbl_name, MAX_TABLE_NAME_LEN + 1);
}

/** Look up a column in a table using the system_charset_info collation.
@param[in]      dd_table        data dictionary table
@param[in]      name            column name
@return the column
@retval nullptr if not found */
UNIV_INLINE
const dd::Column*
dd_find_column(
	dd::Table* dd_table,
	const char* name)
{
	for (const dd::Column* c : dd_table->columns()) {
		if (!my_strcasecmp(system_charset_info,
				   c->name().c_str(), name)) {
			return(c);
		}
	}
        return(nullptr);
}

/** Add a hidden column when creating a table.
@param[in,out]  dd_table        table containing user columns and indexes
@param[in]      name            hidden column name
@param[in]      length          length of the column, in bytes
@return the added column, or NULL if there already was a column by that name */
UNIV_INLINE
dd::Column*
dd_add_hidden_column(
        dd::Table*      dd_table,
        const char*     name,
        uint            length)
{
        if (const dd::Column* c = dd_find_column(dd_table, name)) {
                my_error(ER_WRONG_COLUMN_NAME, MYF(0), c->name().c_str());
                return(nullptr);
        }

        dd::Column* col = dd_table->add_column();
        col->set_hidden(true);
        col->set_name(name);
        col->set_type(dd::enum_column_types::STRING);
        col->set_nullable(false);
        col->set_char_length(length);
        col->set_collation_id(my_charset_bin.number);

        return(col);
}


/** Add a hidden index element at the end.
@param[in,out]  index   created index metadata
@param[in]      column  column of the index */
UNIV_INLINE
void
dd_add_hidden_element(dd::Index* index, const dd::Column* column)
{
        dd::Index_element* e = index->add_element(
                const_cast<dd::Column*>(column));
        e->set_hidden(true);
        e->set_order(dd::Index_element::ORDER_ASC);
}

/** Initialize a hidden unique B-tree index.
@param[in,out]  index   created index metadata
@param[in]      name    name of the index
@param[in]      column  column of the index
@return the initialized index */
UNIV_INLINE
dd::Index*
dd_set_hidden_unique_index(
        dd::Index*              index,
        const char*             name,
        const dd::Column*       column)
{
        index->set_name(name);
        index->set_hidden(true);
        index->set_algorithm(dd::Index::IA_BTREE);
        index->set_type(dd::Index::IT_UNIQUE);
        index->set_engine(innobase_hton_name);
        dd_add_hidden_element(index, column);
        return(index);
}

/** Returns a table object based on table id.
@param[in]	table_id	table id
@param[in]	dict_locked	TRUE=data dictionary locked
@param[in]	table_op	operation to perform
@return table, NULL if does not exist */
UNIV_INLINE
dict_table_t*
dd_table_open_on_id_in_mem(
	table_id_t	table_id,
	ibool		dict_locked,
	dict_table_op_t	table_op)
{
	dict_table_t*	table;

	if (!dict_locked) {
		mutex_enter(&dict_sys->mutex);
	}

	ut_ad(mutex_own(&dict_sys->mutex));

	/* Look for the table ID in the hash table */
	ulint	fold = ut_fold_ull(table_id);

	HASH_SEARCH(id_hash, dict_sys->table_id_hash, fold,
		    dict_table_t*, table, ut_ad(table->cached),
		    table->id == table_id);

	ut_ad(!table || table->cached);

	if (table != NULL) {

		if (table->can_be_evicted) {
			dict_move_to_mru(table);
		}

		table->acquire();

		MONITOR_INC(MONITOR_TABLE_REFERENCE);
	} else if (dict_table_is_sdi(table_id)) {

		/* The table is SDI table */
		space_id_t      space_id = dict_sdi_get_space_id(table_id);
		uint32_t        copy_num = dict_sdi_get_copy_num(table_id);

		/* Create in-memory table oject for SDI table */
		dict_index_t*   sdi_index = dict_sdi_create_idx_in_mem(
			space_id, copy_num, false, 0);

		if (sdi_index == NULL) {
			if (!dict_locked) {
				mutex_exit(&dict_sys->mutex);
			}
			return(NULL);
		}

		table = sdi_index->table;

		ut_ad(table != NULL);

		table->acquire();
	}

	if (!dict_locked) {
		mutex_exit(&dict_sys->mutex);
	}

        return(table);
}

/** Returns a table object based on table id.
@param[in]	table_id	table id
@param[in]	dict_locked	TRUE=data dictionary locked
@param[in]	table_op	operation to perform
@return table, NULL if does not exist */
UNIV_INLINE
dict_table_t*
dd_table_open_on_name_in_mem(
	const char*	name,
	ibool		dict_locked,
	ulint		ignore_op)
{
	dict_table_t*	table = nullptr;

	if (!dict_locked) {
		mutex_enter(&dict_sys->mutex);
	}

	ut_ad(mutex_own(&dict_sys->mutex));

	ut_ad(name);

	/* Look for the table name in the hash table */
	ulint	fold = ut_fold_string(name);

	HASH_SEARCH(name_hash, dict_sys->table_hash, fold,
                    dict_table_t*, table, ut_ad(table->cached),
                    !strcmp(table->name.m_name, name));

	ut_ad(!table || table->cached);

	if (table != NULL) {
		 if (ignore_op == DICT_ERR_IGNORE_NONE
		     && table->is_corrupted()) {
			/* Make life easy for drop table. */
			dict_table_prevent_eviction(table);

			if (!dict_locked) {
				mutex_exit(&dict_sys->mutex);
			}

			ib::info() << "Table "
				<< table->name
				<< " is corrupted. Please drop the table"
				" and recreate it";
			return(nullptr);
		}

		if (table->can_be_evicted) {
			dict_move_to_mru(table);
		}

		table->acquire();

		MONITOR_INC(MONITOR_TABLE_REFERENCE);
	}

	if (!dict_locked) {
		mutex_exit(&dict_sys->mutex);
	}

	return(table);
}
